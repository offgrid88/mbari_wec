{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Background The Monterey Bay Aquarium Research Institute ( MBARI ) Wave-Energy converter is a point-absorber type wave-energy converter that has been operating in Monterey Bay, CA since 2014. This system was developed as part of MBARI's goals of advancing and demonstrating an autonomous and persistent presence of oceanographic instrumentation in the worlds oceans. This project is complemented by developments in autonomous underwater vehicles, underwater vehicle docking, oceanographic instrumentation, autonomy, and science use. The MBARI-WEC is currently maintained by MBARI and operates for six-month periods near the MBARI facility in Moss Landing, California, and averages about 250 Watts of power capture, averaged through the weather cycles and seasons. THe MBARI WEC is a complete system with a four-quadrant electro-hydraulic power-take-off device, board battery storage, control-computers, sensors and instrumentation, and an always-on cell-modem connection to the internet. The architecture of the system is such that critical functions are performed by micro-controllers throughout the system that implement default behaviors and stream sensor data continuously. A Linux computer on the buoy performs data-logging and provides a command interface to the underlying micro-controllers. The system is designed such that the Linux computer is not necessary for safe behavior, if this computer re-boots or goes offline, the system will default to safe behaviors. Additionally, the micro-controllers will ignore damaging commands from the Linux computer. This architecture allows control algorithms running on the Linux computer to be started, stopped, and changed while the device is at sea through the cell-modem connection. This project provides a software interface to the system to allow such algorithms to be efficiently developed, tested, and executed. Using this interface, MBARI intends to make the system available to external researchers. By providing access to the hardware during the ongoing MBARI deployments of this system, the intention is to provide access to hardware that is often otherwise unavailable. To facilitate this, the project has developed a simulator that provides the same interface as the real hardware, allowing projects the ability to develop and test their work independently, before deployment on the real system which will occur under MBARI supervision. The following sections of this documentation outlines the physical system, describes the software- interfaces available, describes the simulation environment, and provides all information needed to interact with this project. The software interface is built upon the ROS 2 framework, and the simulation environment uses Ignition Gazebo . In addition to descriptions of these systems, the documentation provides a number of tutorials intended to lead a new user through the installation of the necessary tools, basic operation of the system, and provide guidance on implement new algorithms to run on the simulator and ultimately the buoy. This is an open-source project with all necessary code and resources freely available.","title":"Home"},{"location":"#background","text":"The Monterey Bay Aquarium Research Institute ( MBARI ) Wave-Energy converter is a point-absorber type wave-energy converter that has been operating in Monterey Bay, CA since 2014. This system was developed as part of MBARI's goals of advancing and demonstrating an autonomous and persistent presence of oceanographic instrumentation in the worlds oceans. This project is complemented by developments in autonomous underwater vehicles, underwater vehicle docking, oceanographic instrumentation, autonomy, and science use. The MBARI-WEC is currently maintained by MBARI and operates for six-month periods near the MBARI facility in Moss Landing, California, and averages about 250 Watts of power capture, averaged through the weather cycles and seasons. THe MBARI WEC is a complete system with a four-quadrant electro-hydraulic power-take-off device, board battery storage, control-computers, sensors and instrumentation, and an always-on cell-modem connection to the internet. The architecture of the system is such that critical functions are performed by micro-controllers throughout the system that implement default behaviors and stream sensor data continuously. A Linux computer on the buoy performs data-logging and provides a command interface to the underlying micro-controllers. The system is designed such that the Linux computer is not necessary for safe behavior, if this computer re-boots or goes offline, the system will default to safe behaviors. Additionally, the micro-controllers will ignore damaging commands from the Linux computer. This architecture allows control algorithms running on the Linux computer to be started, stopped, and changed while the device is at sea through the cell-modem connection. This project provides a software interface to the system to allow such algorithms to be efficiently developed, tested, and executed. Using this interface, MBARI intends to make the system available to external researchers. By providing access to the hardware during the ongoing MBARI deployments of this system, the intention is to provide access to hardware that is often otherwise unavailable. To facilitate this, the project has developed a simulator that provides the same interface as the real hardware, allowing projects the ability to develop and test their work independently, before deployment on the real system which will occur under MBARI supervision. The following sections of this documentation outlines the physical system, describes the software- interfaces available, describes the simulation environment, and provides all information needed to interact with this project. The software interface is built upon the ROS 2 framework, and the simulation environment uses Ignition Gazebo . In addition to descriptions of these systems, the documentation provides a number of tutorials intended to lead a new user through the installation of the necessary tools, basic operation of the system, and provide guidance on implement new algorithms to run on the simulator and ultimately the buoy. This is an open-source project with all necessary code and resources freely available.","title":"Background"},{"location":"ControlAndTelemetry/","text":"Telemetry","title":"Buoy Control and Telemetry"},{"location":"ControlAndTelemetry/#telemetry","text":"","title":"Telemetry"},{"location":"architecture/","text":"The MBARI Wave-Energy-Converter is a small point absorber design that includes a surface expression, an electro-hydraulic PTO, and a submerged heave-cone device. The system is moored to the seafloor (typically in 80m of water) through a chain-catenary mooring connected to an anchor. As waves excite the system, a differential motion results between the buoy at the surface and the submerged heave cone. Resisting this motion results in energy being absorbed by the system, and this energy is converted to electrical form and stored in a battery bank on the buoy. The rest of this section provides details about the various components of the system Buoy, Heave Cone, and Mooring The buoy in the MBARI-WEC has a diameter of 2.6m, a waterplane area of 5 m^2, and a mass of 1400kg. This buoy houses the system battery and compute infrastructure, described below. The heave-cone component sits at about 30m depth and provides inertia and drag for the surface-buoy to pull against. The heave-cone has operable doors that can be opened to reduce the drag and inertial of this component in high sea-states. When the doors are open, the heave-cone has added-mass of about 10,000kg, in addition to it's own 600kg mass. When opened, the added-mass reduces to about 3,000kg, which reduces the inertial forcing and increses the natural frequency of the buoy -- heave-cone pair. A chain-catenary mooring and anchor connects to heave-cone to the ocean floor, keeping the buoy on-station. The system loading due to the mooring increases in higher winds and currents, but remains relatively low compared with the inertia forces the heave-cone creates. PTO System The power take-off device is located below the buoy and converts the differential motion and forces between the buoy and heave-cone from mechanical to eletrical energy. This device is an electro-hydraulic device in which a piston pumps oil through a hydraulic motor, causing an electrical motor/generator to spin and generate electrical energy. In parallel to the hydraulic ram, a pneumatic piston charged with an inert gas provides a sprint returning force for the system. The combination of the hydraulic and pneumatic pistons creates a spring-damper system for which the spring constant is set by the amount of gas in the systen, and the damping behavior is adjustable electronically by varying the torque on the hydraulic motor in response to conditions. The electrical-drive is a four-quadrant device in which the electric motor can operate as a generator in which energy flows into the battery, or as a motor in which energy is drawn from the battery. The winding-currents (and resulting torque) can be set arbitrarily, but by default the power take-off device acts as a generator, i.e. a damper resisting motion. Electrical System The electrical system of this buoy consists of a 325V battery system for energy storage, and a 24V system for powering ancillary instrumenation. The 325V battery is connected directly to the power take-off device motor drive electronics. In normal use, the motor-drive device is generating electrial energy at 325V which charges the battery system. In the case the battery is full (or dis-connected), the motor-drive system directs excess energy to an electrical load-dump device. This submerged heater plays a critcal role in maintaining a load on the power take-off device at all times. The electrical system also includes 300V-24V power supplies that provides 24 volts to the compute and instrumentation infrastructure in the system. In the case of low battery voltage due to an extended period of calm seas, the Compute and Control Systems The compute and control architecture of the system is such that critical functions are performed by micro-controllers throughout the system that implement default behaviors and stream sensor data continously. A Linux computer on the buoy performs data-logging and provides a command interface to the underlying micro-controllers. See figure. The system is designed such that the Linux computer is not necessary for safe behavior, if this computer re-boots or goes offline, the system will default to safe behaviors. Additionally, the microcontrollers will ignore damaging commands from the Linux computer. This architecture allows control algorithms running on the Linux computer to be started, stopped, and changed while the device is at sea through the cell-modem connection. The fundamental system behaviors are performed by a network of micro-controller based compute nodes, that communicate with the buoy Linux computer and with one-another through a Controller Area Network (CAN) bus. There are four of these controllers as follows: Battery Controller (BC_): This micro-controller monitors battery voltage, currents, state-of-charge, cell-balance, and environmental conditions inside the battery enclosure. This controller is largely a data-telemetery gathering item, but also includes an important low-voltage disconnect features which shuts down the 24V battery bus during periods of low-battery state-of-charge. During these periods the system continues to convert wave-energy and charge the batteries, but all sources of significant battery drain are disconnected which allows the battery to re-charge to a servicable level, even in calm conditions. Spring Controller (SC_): This micro-controller primarily monitors the piston position and a load-cell located between the buoy and power take-off component. Additionally, this controller responds to commands to change the gas pressure in each chamber of the pneumatic spring, a pumop to move gas from the lower pressure chamber to the higher pressure chamber, and a valve to do the opposite. Additionally, this controller can turn power on and off to the heave-cone. Power Converter (PC_): This controller implements the field-oriented control of the winding current in the generator. Heave-cone Controller (TC_): This The on-board linux computer is assessible from shore over a radio link (cell-modem, satellite, or line-of-site radio). This link enables enabling data-telemetry, real-time control, and software-updates to be applied to the Linux computer. Sensors and Measurements Load Cell: This is a load cell between the buoy and the power take-off device, and has a range of up to 20,000lbs. Piston Position: Inside the pneumatic spring there is a laser range-finder that contiously monitors the position of the power take-off piston. Pneumatic Pressures: The spring controller monitors the pressures of the two gas-chambers that make up the pneumatic spring. Buoy Inertial Measurement Unit: On-board the buoy there is a GPS disciplined six DOF attitude-heading and reference system. This unit monitors and resports the buoys attitude and GPS location. Heave Cone Inertial Measurement Unit: On-board the heave-cone there is an attitude-heading and reference system with a magnetometer and pressure sensor that reports the heave-cones orientation and depth. Electrical System Sensors: RADAR: Instrumentation Interface","title":"Architecture"},{"location":"architecture/#buoy-heave-cone-and-mooring","text":"The buoy in the MBARI-WEC has a diameter of 2.6m, a waterplane area of 5 m^2, and a mass of 1400kg. This buoy houses the system battery and compute infrastructure, described below. The heave-cone component sits at about 30m depth and provides inertia and drag for the surface-buoy to pull against. The heave-cone has operable doors that can be opened to reduce the drag and inertial of this component in high sea-states. When the doors are open, the heave-cone has added-mass of about 10,000kg, in addition to it's own 600kg mass. When opened, the added-mass reduces to about 3,000kg, which reduces the inertial forcing and increses the natural frequency of the buoy -- heave-cone pair. A chain-catenary mooring and anchor connects to heave-cone to the ocean floor, keeping the buoy on-station. The system loading due to the mooring increases in higher winds and currents, but remains relatively low compared with the inertia forces the heave-cone creates.","title":"Buoy, Heave Cone, and Mooring"},{"location":"architecture/#pto-system","text":"The power take-off device is located below the buoy and converts the differential motion and forces between the buoy and heave-cone from mechanical to eletrical energy. This device is an electro-hydraulic device in which a piston pumps oil through a hydraulic motor, causing an electrical motor/generator to spin and generate electrical energy. In parallel to the hydraulic ram, a pneumatic piston charged with an inert gas provides a sprint returning force for the system. The combination of the hydraulic and pneumatic pistons creates a spring-damper system for which the spring constant is set by the amount of gas in the systen, and the damping behavior is adjustable electronically by varying the torque on the hydraulic motor in response to conditions. The electrical-drive is a four-quadrant device in which the electric motor can operate as a generator in which energy flows into the battery, or as a motor in which energy is drawn from the battery. The winding-currents (and resulting torque) can be set arbitrarily, but by default the power take-off device acts as a generator, i.e. a damper resisting motion.","title":"PTO System"},{"location":"architecture/#electrical-system","text":"The electrical system of this buoy consists of a 325V battery system for energy storage, and a 24V system for powering ancillary instrumenation. The 325V battery is connected directly to the power take-off device motor drive electronics. In normal use, the motor-drive device is generating electrial energy at 325V which charges the battery system. In the case the battery is full (or dis-connected), the motor-drive system directs excess energy to an electrical load-dump device. This submerged heater plays a critcal role in maintaining a load on the power take-off device at all times. The electrical system also includes 300V-24V power supplies that provides 24 volts to the compute and instrumentation infrastructure in the system. In the case of low battery voltage due to an extended period of calm seas, the","title":"Electrical System"},{"location":"architecture/#compute-and-control-systems","text":"The compute and control architecture of the system is such that critical functions are performed by micro-controllers throughout the system that implement default behaviors and stream sensor data continously. A Linux computer on the buoy performs data-logging and provides a command interface to the underlying micro-controllers. See figure. The system is designed such that the Linux computer is not necessary for safe behavior, if this computer re-boots or goes offline, the system will default to safe behaviors. Additionally, the microcontrollers will ignore damaging commands from the Linux computer. This architecture allows control algorithms running on the Linux computer to be started, stopped, and changed while the device is at sea through the cell-modem connection. The fundamental system behaviors are performed by a network of micro-controller based compute nodes, that communicate with the buoy Linux computer and with one-another through a Controller Area Network (CAN) bus. There are four of these controllers as follows: Battery Controller (BC_): This micro-controller monitors battery voltage, currents, state-of-charge, cell-balance, and environmental conditions inside the battery enclosure. This controller is largely a data-telemetery gathering item, but also includes an important low-voltage disconnect features which shuts down the 24V battery bus during periods of low-battery state-of-charge. During these periods the system continues to convert wave-energy and charge the batteries, but all sources of significant battery drain are disconnected which allows the battery to re-charge to a servicable level, even in calm conditions. Spring Controller (SC_): This micro-controller primarily monitors the piston position and a load-cell located between the buoy and power take-off component. Additionally, this controller responds to commands to change the gas pressure in each chamber of the pneumatic spring, a pumop to move gas from the lower pressure chamber to the higher pressure chamber, and a valve to do the opposite. Additionally, this controller can turn power on and off to the heave-cone. Power Converter (PC_): This controller implements the field-oriented control of the winding current in the generator. Heave-cone Controller (TC_): This The on-board linux computer is assessible from shore over a radio link (cell-modem, satellite, or line-of-site radio). This link enables enabling data-telemetry, real-time control, and software-updates to be applied to the Linux computer.","title":"Compute and Control Systems"},{"location":"architecture/#sensors-and-measurements","text":"Load Cell: This is a load cell between the buoy and the power take-off device, and has a range of up to 20,000lbs. Piston Position: Inside the pneumatic spring there is a laser range-finder that contiously monitors the position of the power take-off piston. Pneumatic Pressures: The spring controller monitors the pressures of the two gas-chambers that make up the pneumatic spring. Buoy Inertial Measurement Unit: On-board the buoy there is a GPS disciplined six DOF attitude-heading and reference system. This unit monitors and resports the buoys attitude and GPS location. Heave Cone Inertial Measurement Unit: On-board the heave-cone there is an attitude-heading and reference system with a magnetometer and pressure sensor that reports the heave-cones orientation and depth. Electrical System Sensors: RADAR:","title":"Sensors and Measurements"},{"location":"architecture/#instrumentation-interface","text":"","title":"Instrumentation Interface"},{"location":"atseaoperation/","text":"Under Construction","title":"At Sea Operation"},{"location":"citation/","text":"Under Construction","title":"How to Cite"},{"location":"license/","text":"Copyright 2022 Open Source Robotics Foundation, Inc. and Monterey Bay Aquarium Research Institute Licensed under the Apache License, Version 2.0","title":"License"},{"location":"resources/","text":"Forum This project maintains a discussion forum at TBD and we try to respond as quickly as possible to all questions and discussion. This is the best way to reach the developers and maintainers of this project Source Code The simulator used in this project utilizes the Ignition Gazebo simulator as the base, with a number of custom PlugIns developed by this project to implement specific features needed to simulate this WEC. Ignition Gazebo and this projects plugins are open source projects and the source code for these can be accessed at https://github.com/gazebosim/gz-sim and https://github.com/osrf/buoy_entrypoint . Documentation in these respositories is intended for developers but does provide some detailed information about how the simulation works. Publications References","title":"Resources"},{"location":"resources/#forum","text":"This project maintains a discussion forum at TBD and we try to respond as quickly as possible to all questions and discussion. This is the best way to reach the developers and maintainers of this project","title":"Forum"},{"location":"resources/#source-code","text":"The simulator used in this project utilizes the Ignition Gazebo simulator as the base, with a number of custom PlugIns developed by this project to implement specific features needed to simulate this WEC. Ignition Gazebo and this projects plugins are open source projects and the source code for these can be accessed at https://github.com/gazebosim/gz-sim and https://github.com/osrf/buoy_entrypoint . Documentation in these respositories is intended for developers but does provide some detailed information about how the simulation works.","title":"Source Code"},{"location":"resources/#publications","text":"","title":"Publications"},{"location":"resources/#references","text":"","title":"References"},{"location":"ros2/","text":"Under Construction","title":"ROS2 Interface"},{"location":"simulation/","text":"Under Construction","title":"Simulation"},{"location":"theory/","text":"Modeling Technique Overview The numerical modeling used in this simulator relies upon the Gazebo simulators ability to solve for the motion of a collection of rigid bodies connected by various types of joints. Gazebo can use several different physics solvers to perform this solution, and the wave-energy buoy simulator in this project uses the DART physics engine. The physics engine solves the multi-body six degree-of-freedom problem for the motion of the connected buoy, power-take-off device, and heave cone, subject to initial conditions and forces that act on the various components as the simulation progresses. In the Gazebo simulator, these forces are provided by plugin code that applies forces to each body based on the state (position and velocity) of each component in the system at each timestep. The Gazebo simulator already includes several plugins that provide relevant forces such as buoyancy and hydrodynamic drag. Additionally, several additional plugins have been created for this simulator that provide the forcings on the system due to the electro-hydraulic power-take-off system, the pneumatic spring system, the tether connecting the PTO to the heave-cone, the mooring system that anchors the system, and the forcing on the buoy from the ocean surface waves. The sections below outline some details about how each of these forcings are modelled and computed. First however, the specific physical characteristics of the MBARI WEC are tabulated for reference. Physical Characteristics Each rigid body in the simulation has a \"Link Frame\" coordinate system in which all other characteristics of the body are defined in for computational purposes. This link-frame coordinate system is often selected to be at the location of a joint that connects the various bodies (which are also called links in the vernacular of Gazebo). Also, the description below includes alternative notation for added mass, e.g. \\\\ \\mu_{xx} , in the style of Newman. Surface Buoy Description Units m Buoy Mass 1400 kg V Displacement (undisturbed buoy) 2.39 m ^3 {\\bf x}_{COG} Center of Gravity in Link Frame (x,y,z) (0.0, 0.0, 2.03) m {\\bf x}_{COB} Center of Buoyancy in Link Frame (x,y,z) (0.0, 0.0, 2.05) m {\\bf x}_{COW} Center of Waterplane in Link Frame, including PTO and cone (0.0, 0.0, 2.27) m S_{x} Second moment of area of water plane, about roll axis 1.37 m ^4 S_{y} Second moment of area of water plane, about pitch axis 1.37 m ^4 I_{xx} Roll Moment of Inertia (MOI) about center of mass 1450 kg m ^2 I_{yy} Pitch Moment of Inertia about center of mass 1450 kg m ^2 I_{zz} Yaw Moment of Inertia about center of mass 670 kg m ^2 A_{wp} Waterplane Area (undisturbed buoy) 5.47 m ^2 X_{\\dot{u}} Surge Added Mass ( \\mu_{xx} ) 260 kg X_{\\dot{q}} Surge-Pitch Added Mass, origin at pivot ( \\mu_{xq} ) 370 kg Y_{\\dot{v}} Sway Added Mass ( \\mu_{yy} ) 260 kg Y_{\\dot{p}} Sway-Roll Added Mass, origin at pivot ( \\mu_{yp} ) -370 kg Z_{\\dot{w}} Heave Added Mass ( \\mu_{zz} ) 3080 kg K_{\\dot{p}} Roll Added Mass MOI, origin at pivot ( \\mu_{pp} ) 780 kg m ^2 M_{\\dot{q}} Pitch Added Mass MOI, origin at pivot ( \\mu_{qq} ) 780 kg m ^2 X_{u\\mid u \\mid} Surge Quadratic Drag -430 kg/m Y_{v\\mid v \\mid} Sway Quadratic Drag -430 kg/m Z_{w\\mid w \\mid} Heave Quadratic Drag -3280 kg/m K_{p\\mid p \\mid} Roll Quadratic Drag: -880 kg m ^2 M_{q\\mid q \\mid} Pitch Quadratic Drag: -880 kg m ^2 N_{r\\mid r \\mid} Yaw Quadratic Drag: -50 kg m ^2 Buoy Link Frame is located at base of the buoy bridle at the pivot. Unspecified stability derivative values ( M_{\\dot{r}} , X_{uv} , Y_{vu} , etc) are zero. Added mass moments of inertia and stability derivatives are all specified about the link frame origin, i.e. the pivot. Mass moments of inertia are specified about the center of mass. Added mass values are infinite frequency. Free-Surface Hydrodynamic Coefficients and Impulse Response Functions can be found here : Power Take-Off Device Description Units m PTO Mass 605 kg V PTO Displacement .205 m ^3 {\\bf x}_{COG} Center of Gravity in Link Frame (x,y,z) (0.0, 0.0, -4.0) m {\\bf x}_{COB} Center of Buoyancy in Link Frame (x,y,z) (0.0, 0.0, -3.0) m I_{xx} Roll Moment of Inertia about center of mass 3525 kg m ^2 I_{yy} Pitch Moment of Inertia about center of mass 3525 kg m ^2 I_{zz} Yaw Moment of Inertia about center of mass 10 kg m ^2 X_{\\dot{u}} Surge Added Mass ( \\mu_{xx} ) 310 kg X_{\\dot{q}} Surge-Pitch Added Mass MOI ( \\mu_{xq} ) 1250 kg m Y_{\\dot{v}} Sway Added Mass ( \\mu_{yy} ) 310 kg Y_{\\dot{p}} Sway-Roll Added Mass MOI ( \\mu_{yp} ) -1250 kg m Z_{\\dot{w}} Heave Added Mass ( \\mu_{zz} ) 10 kg K_{\\dot{p}} Roll Added Mass MOI ( \\mu_{pp} ) 7040 kg m ^2 M_{\\dot{q}} Pitch Added Mass MOI ( \\mu_{qq} ) 7040 kg m ^2 X_{u\\mid u \\mid} Surge Quadratic Drag -1140 kg/m Y_{v\\mid v \\mid} Sway Quadratic Drag -1140 kg/m Z_{w\\mid w \\mid} Heave Quadratic Drag -50 kg/m K_{p\\mid p \\mid} Roll Quadratic Drag -195400 kg m ^2 M_{p\\mid p \\mid} Pitch Quadratic Drag -195400 kg m ^2 N_{r\\mid r \\mid} Yaw Quadratic Drag -50 kg m ^2 PTO Link Frame is located at top attachment of the PTO (where connects to the buoy). Unspecified stability derivative values ( M_{\\dot{r}} , X_{uv} , Y_{vu} , etc) are zero. Added mass moments of inertia and stability derivatives are all specified about the link frame origin. Mass moments of inertia are specified about the center of mass. Piston Description Units m Piston Mass 48.0 kg {\\bf x}_{COG} Center of Gravity in Link Frame (x,y,z) (0.0, 0.0, -2.58) m I_{xx} Roll Moment of Inertia 100.0 kg m ^2 I_{yy} Pitch Moment of Inertia 100.0 kg m ^2 I_{zz} Yaw Moment of Inertia 5.0 kg m ^2 The piston is contained with the PTO housing, so it has mass and moments of inertial, but contributes no buoyancy, added mass, or quadratic fluid drag. Heave Cone Description Units m Heave Cone Mass 820 kg V Heave Cone Displacement .12 m ^3 {\\bf x}_{COG} Center of Gravity in Link Frame (x,y,z) (0.0, 0.0, -1.25) m {\\bf x}_{COB} Center of Buoyancy in Link Frame (x,y,z) (0.0, 0.0, -1.21) m I_{xx} Roll Moment of Inertia about the center of mass 340 kg m ^2 I_{yy} Pitch Moment of Inertia about the center of mass 340 kg m ^2 I_{zz} Yaw Moment of Inertia about the center of mass 610 kg m ^2 X_{\\dot{u}} Surge Added Mass ( \\mu_{xx} ) 720 kg X_{\\dot{q}} Surge-Pitch Added Mass MOI ( \\mu_{xq} ) 900 kg m Y_{\\dot{v}} Sway Added Mass ( \\mu_{yy} ) 720 kg Y_{\\dot{p}} Sway-Roll Added Mass MOI ( \\mu_{yp} ) -900 kg m Z_{\\dot{w}} Heave Added Mass: Doors Closed ( \\mu_{zz} ) 9330 kg Z_{\\dot{w}} Heave Added Mass: Doors Open 3000 kg K_{\\dot{p}} Roll Added Mass MOI ( \\mu_{pp} ) 3990 kg m ^2 M_{\\dot{q}} Pitch Added Mass MOI( \\mu_{qq} ) 3990 kg m ^2 N_{\\dot{r}} Yaw Added Mass MOI ( \\mu_{rr} ) 10 kg m ^2 X_{u\\mid u \\mid} Surge Quadratic Drag -1580 kg/m Y_{v\\mid v \\mid} Sway Quadratic Drag -1580 kg/m Z_{w\\mid w \\mid} Vertical Quadratic Drag: Doors Open -3200 kg/m Z_{w\\mid w \\mid} Vertical Quadratic Drag: Doors Closed -3900 kg/m K_{p\\mid p \\mid} Roll Quadratic Drag: -4620 kg m ^2 M_{q\\mid q \\mid} Pitch Quadratic Drag: -4620 kg m ^2 N_{r\\mid r \\mid} Yaw Quadratic Drag: -50 kg m ^2 Heave-Cone Link Frame is located at top attachment of the Heave Cone (where it connects to the tether). Unspecified stability derivative values ( M_{\\dot{r}} , X_{uv} , Y_{vu} , etc) are zero. Added mass moments of inertia and stability derivatives are all specified about the link frame origin. Mass moments of inertia are specified about the center of mass. Electro-Hydraulic PTO Forces Pneumatic Spring Forces Definitions Description Units x Piston position m v Piston velocity m/s m Mass of gas in chamber kg T Temperature of gas K P Gas pressure Pa V Chamber volume (dependent on piston position) m ^{3} R_{specific} Specific Gas Constant N _2 J/kg/K V_{dead} Chamber dead volume (fully compressed) m ^{3} c_p Specific Heat Capacity N _2 (constant pressure) J/kg/K A_{piston} Surface area of piston head m ^{2} n Polytropic index (Adiabatic if n=\\lambda=1.4 for N _2 ) N/A r Coefficient of heat transfer (Newton's Law of Cooling) 1/s Model Under compression and expansion, the pressure, volume and temperature of the Nitrogen in each chamber evolves according to Ideal Gas Law: P V = m R_{specific} T and a polytropic process: P = P_0 \\left({V_{0} \\over V}\\right)^{n} with hysteresis, there are two values for the polytropic index, n_1 and n_2 , to capture behavior when the gas is compressing or expanding. Using this quasi-static solution and discrete time steps, and also incorporating hysteresis, the process becomes: V_k = x_k A_{piston} + V_{dead} P_k = P_{k-1} \\left({V_{k-1} \\over V_k}\\right)^n ,\\,\\,\\, n = \\begin{cases} n_1 & \\text{if } v \\ge 0 \\\\ n_2 & \\text{otherwise.} \\end{cases} T_k = {P_k V_k \\over m R_{specific}} where k is the current time step. Whenever the piston velocity is slow enough, the process is dominated by heat loss and modeled with Newton's Law of Cooling (using forward difference) followed by an update of pressure using Ideal Gas Law: T_k = r\\, \\Delta t\\, (T_{env} - T_{k-1}) + T_{k-1} V_k = x_k A_{piston} + V_{dead} P_k = {m R_{specific} T_k \\over V_k} The mass of the Nitrogen in each chamber is determined from inputs in the SDF: m = {P_0 (x_0 A_{piston} + V_{dead}) \\over R_{specific} T_0} and is used for mass flow between chambers in simulating the pump/valve. Determining Parameter Values Linear regression was used to determine the polytropic indices for each chamber using empirical data from the physical system. Using pressure vs volume curves, n_1 is determined from increasing volume, and n_2 is determined from decreasing volume. The data is then preconditioned by taking the logarithm to linearize and perform regression to find the parameters. For a polytropic process: P V^{n} = C so, \\log{P} + n \\log{V} = \\log{C} \\left[ { \\begin{array}{cc} \\log{\\bf V} & 1 \\\\ \\end{array} } \\right] \\left[ { \\begin{array}{c} -n \\\\ \\log{C} \\\\ \\end{array} } \\right] = \\log{\\bf P} in block matrix notation where {\\bf V} and {\\bf P} are the arrays of volume and pressure data, respectively. The other parameters in the system are taken from CAD or empirically determined by comparing logged data from prescribed motion between simulation and the physical test bench. Tether Forces Mooring Forces Ocean Wave Forces","title":"Theory"},{"location":"theory/#modeling-technique-overview","text":"The numerical modeling used in this simulator relies upon the Gazebo simulators ability to solve for the motion of a collection of rigid bodies connected by various types of joints. Gazebo can use several different physics solvers to perform this solution, and the wave-energy buoy simulator in this project uses the DART physics engine. The physics engine solves the multi-body six degree-of-freedom problem for the motion of the connected buoy, power-take-off device, and heave cone, subject to initial conditions and forces that act on the various components as the simulation progresses. In the Gazebo simulator, these forces are provided by plugin code that applies forces to each body based on the state (position and velocity) of each component in the system at each timestep. The Gazebo simulator already includes several plugins that provide relevant forces such as buoyancy and hydrodynamic drag. Additionally, several additional plugins have been created for this simulator that provide the forcings on the system due to the electro-hydraulic power-take-off system, the pneumatic spring system, the tether connecting the PTO to the heave-cone, the mooring system that anchors the system, and the forcing on the buoy from the ocean surface waves. The sections below outline some details about how each of these forcings are modelled and computed. First however, the specific physical characteristics of the MBARI WEC are tabulated for reference.","title":"Modeling Technique Overview"},{"location":"theory/#physical-characteristics","text":"Each rigid body in the simulation has a \"Link Frame\" coordinate system in which all other characteristics of the body are defined in for computational purposes. This link-frame coordinate system is often selected to be at the location of a joint that connects the various bodies (which are also called links in the vernacular of Gazebo). Also, the description below includes alternative notation for added mass, e.g. \\\\ \\mu_{xx} , in the style of Newman.","title":"Physical Characteristics"},{"location":"theory/#surface-buoy","text":"Description Units m Buoy Mass 1400 kg V Displacement (undisturbed buoy) 2.39 m ^3 {\\bf x}_{COG} Center of Gravity in Link Frame (x,y,z) (0.0, 0.0, 2.03) m {\\bf x}_{COB} Center of Buoyancy in Link Frame (x,y,z) (0.0, 0.0, 2.05) m {\\bf x}_{COW} Center of Waterplane in Link Frame, including PTO and cone (0.0, 0.0, 2.27) m S_{x} Second moment of area of water plane, about roll axis 1.37 m ^4 S_{y} Second moment of area of water plane, about pitch axis 1.37 m ^4 I_{xx} Roll Moment of Inertia (MOI) about center of mass 1450 kg m ^2 I_{yy} Pitch Moment of Inertia about center of mass 1450 kg m ^2 I_{zz} Yaw Moment of Inertia about center of mass 670 kg m ^2 A_{wp} Waterplane Area (undisturbed buoy) 5.47 m ^2 X_{\\dot{u}} Surge Added Mass ( \\mu_{xx} ) 260 kg X_{\\dot{q}} Surge-Pitch Added Mass, origin at pivot ( \\mu_{xq} ) 370 kg Y_{\\dot{v}} Sway Added Mass ( \\mu_{yy} ) 260 kg Y_{\\dot{p}} Sway-Roll Added Mass, origin at pivot ( \\mu_{yp} ) -370 kg Z_{\\dot{w}} Heave Added Mass ( \\mu_{zz} ) 3080 kg K_{\\dot{p}} Roll Added Mass MOI, origin at pivot ( \\mu_{pp} ) 780 kg m ^2 M_{\\dot{q}} Pitch Added Mass MOI, origin at pivot ( \\mu_{qq} ) 780 kg m ^2 X_{u\\mid u \\mid} Surge Quadratic Drag -430 kg/m Y_{v\\mid v \\mid} Sway Quadratic Drag -430 kg/m Z_{w\\mid w \\mid} Heave Quadratic Drag -3280 kg/m K_{p\\mid p \\mid} Roll Quadratic Drag: -880 kg m ^2 M_{q\\mid q \\mid} Pitch Quadratic Drag: -880 kg m ^2 N_{r\\mid r \\mid} Yaw Quadratic Drag: -50 kg m ^2 Buoy Link Frame is located at base of the buoy bridle at the pivot. Unspecified stability derivative values ( M_{\\dot{r}} , X_{uv} , Y_{vu} , etc) are zero. Added mass moments of inertia and stability derivatives are all specified about the link frame origin, i.e. the pivot. Mass moments of inertia are specified about the center of mass. Added mass values are infinite frequency. Free-Surface Hydrodynamic Coefficients and Impulse Response Functions can be found here :","title":"Surface Buoy"},{"location":"theory/#power-take-off-device","text":"Description Units m PTO Mass 605 kg V PTO Displacement .205 m ^3 {\\bf x}_{COG} Center of Gravity in Link Frame (x,y,z) (0.0, 0.0, -4.0) m {\\bf x}_{COB} Center of Buoyancy in Link Frame (x,y,z) (0.0, 0.0, -3.0) m I_{xx} Roll Moment of Inertia about center of mass 3525 kg m ^2 I_{yy} Pitch Moment of Inertia about center of mass 3525 kg m ^2 I_{zz} Yaw Moment of Inertia about center of mass 10 kg m ^2 X_{\\dot{u}} Surge Added Mass ( \\mu_{xx} ) 310 kg X_{\\dot{q}} Surge-Pitch Added Mass MOI ( \\mu_{xq} ) 1250 kg m Y_{\\dot{v}} Sway Added Mass ( \\mu_{yy} ) 310 kg Y_{\\dot{p}} Sway-Roll Added Mass MOI ( \\mu_{yp} ) -1250 kg m Z_{\\dot{w}} Heave Added Mass ( \\mu_{zz} ) 10 kg K_{\\dot{p}} Roll Added Mass MOI ( \\mu_{pp} ) 7040 kg m ^2 M_{\\dot{q}} Pitch Added Mass MOI ( \\mu_{qq} ) 7040 kg m ^2 X_{u\\mid u \\mid} Surge Quadratic Drag -1140 kg/m Y_{v\\mid v \\mid} Sway Quadratic Drag -1140 kg/m Z_{w\\mid w \\mid} Heave Quadratic Drag -50 kg/m K_{p\\mid p \\mid} Roll Quadratic Drag -195400 kg m ^2 M_{p\\mid p \\mid} Pitch Quadratic Drag -195400 kg m ^2 N_{r\\mid r \\mid} Yaw Quadratic Drag -50 kg m ^2 PTO Link Frame is located at top attachment of the PTO (where connects to the buoy). Unspecified stability derivative values ( M_{\\dot{r}} , X_{uv} , Y_{vu} , etc) are zero. Added mass moments of inertia and stability derivatives are all specified about the link frame origin. Mass moments of inertia are specified about the center of mass.","title":"Power Take-Off Device"},{"location":"theory/#piston","text":"Description Units m Piston Mass 48.0 kg {\\bf x}_{COG} Center of Gravity in Link Frame (x,y,z) (0.0, 0.0, -2.58) m I_{xx} Roll Moment of Inertia 100.0 kg m ^2 I_{yy} Pitch Moment of Inertia 100.0 kg m ^2 I_{zz} Yaw Moment of Inertia 5.0 kg m ^2 The piston is contained with the PTO housing, so it has mass and moments of inertial, but contributes no buoyancy, added mass, or quadratic fluid drag.","title":"Piston"},{"location":"theory/#heave-cone","text":"Description Units m Heave Cone Mass 820 kg V Heave Cone Displacement .12 m ^3 {\\bf x}_{COG} Center of Gravity in Link Frame (x,y,z) (0.0, 0.0, -1.25) m {\\bf x}_{COB} Center of Buoyancy in Link Frame (x,y,z) (0.0, 0.0, -1.21) m I_{xx} Roll Moment of Inertia about the center of mass 340 kg m ^2 I_{yy} Pitch Moment of Inertia about the center of mass 340 kg m ^2 I_{zz} Yaw Moment of Inertia about the center of mass 610 kg m ^2 X_{\\dot{u}} Surge Added Mass ( \\mu_{xx} ) 720 kg X_{\\dot{q}} Surge-Pitch Added Mass MOI ( \\mu_{xq} ) 900 kg m Y_{\\dot{v}} Sway Added Mass ( \\mu_{yy} ) 720 kg Y_{\\dot{p}} Sway-Roll Added Mass MOI ( \\mu_{yp} ) -900 kg m Z_{\\dot{w}} Heave Added Mass: Doors Closed ( \\mu_{zz} ) 9330 kg Z_{\\dot{w}} Heave Added Mass: Doors Open 3000 kg K_{\\dot{p}} Roll Added Mass MOI ( \\mu_{pp} ) 3990 kg m ^2 M_{\\dot{q}} Pitch Added Mass MOI( \\mu_{qq} ) 3990 kg m ^2 N_{\\dot{r}} Yaw Added Mass MOI ( \\mu_{rr} ) 10 kg m ^2 X_{u\\mid u \\mid} Surge Quadratic Drag -1580 kg/m Y_{v\\mid v \\mid} Sway Quadratic Drag -1580 kg/m Z_{w\\mid w \\mid} Vertical Quadratic Drag: Doors Open -3200 kg/m Z_{w\\mid w \\mid} Vertical Quadratic Drag: Doors Closed -3900 kg/m K_{p\\mid p \\mid} Roll Quadratic Drag: -4620 kg m ^2 M_{q\\mid q \\mid} Pitch Quadratic Drag: -4620 kg m ^2 N_{r\\mid r \\mid} Yaw Quadratic Drag: -50 kg m ^2 Heave-Cone Link Frame is located at top attachment of the Heave Cone (where it connects to the tether). Unspecified stability derivative values ( M_{\\dot{r}} , X_{uv} , Y_{vu} , etc) are zero. Added mass moments of inertia and stability derivatives are all specified about the link frame origin. Mass moments of inertia are specified about the center of mass.","title":"Heave Cone"},{"location":"theory/#electro-hydraulic-pto-forces","text":"","title":"Electro-Hydraulic PTO Forces"},{"location":"theory/#pneumatic-spring-forces","text":"","title":"Pneumatic Spring Forces"},{"location":"theory/#definitions","text":"Description Units x Piston position m v Piston velocity m/s m Mass of gas in chamber kg T Temperature of gas K P Gas pressure Pa V Chamber volume (dependent on piston position) m ^{3} R_{specific} Specific Gas Constant N _2 J/kg/K V_{dead} Chamber dead volume (fully compressed) m ^{3} c_p Specific Heat Capacity N _2 (constant pressure) J/kg/K A_{piston} Surface area of piston head m ^{2} n Polytropic index (Adiabatic if n=\\lambda=1.4 for N _2 ) N/A r Coefficient of heat transfer (Newton's Law of Cooling) 1/s","title":"Definitions"},{"location":"theory/#model","text":"Under compression and expansion, the pressure, volume and temperature of the Nitrogen in each chamber evolves according to Ideal Gas Law: P V = m R_{specific} T and a polytropic process: P = P_0 \\left({V_{0} \\over V}\\right)^{n} with hysteresis, there are two values for the polytropic index, n_1 and n_2 , to capture behavior when the gas is compressing or expanding. Using this quasi-static solution and discrete time steps, and also incorporating hysteresis, the process becomes: V_k = x_k A_{piston} + V_{dead} P_k = P_{k-1} \\left({V_{k-1} \\over V_k}\\right)^n ,\\,\\,\\, n = \\begin{cases} n_1 & \\text{if } v \\ge 0 \\\\ n_2 & \\text{otherwise.} \\end{cases} T_k = {P_k V_k \\over m R_{specific}} where k is the current time step. Whenever the piston velocity is slow enough, the process is dominated by heat loss and modeled with Newton's Law of Cooling (using forward difference) followed by an update of pressure using Ideal Gas Law: T_k = r\\, \\Delta t\\, (T_{env} - T_{k-1}) + T_{k-1} V_k = x_k A_{piston} + V_{dead} P_k = {m R_{specific} T_k \\over V_k} The mass of the Nitrogen in each chamber is determined from inputs in the SDF: m = {P_0 (x_0 A_{piston} + V_{dead}) \\over R_{specific} T_0} and is used for mass flow between chambers in simulating the pump/valve.","title":"Model"},{"location":"theory/#determining-parameter-values","text":"Linear regression was used to determine the polytropic indices for each chamber using empirical data from the physical system. Using pressure vs volume curves, n_1 is determined from increasing volume, and n_2 is determined from decreasing volume. The data is then preconditioned by taking the logarithm to linearize and perform regression to find the parameters. For a polytropic process: P V^{n} = C so, \\log{P} + n \\log{V} = \\log{C} \\left[ { \\begin{array}{cc} \\log{\\bf V} & 1 \\\\ \\end{array} } \\right] \\left[ { \\begin{array}{c} -n \\\\ \\log{C} \\\\ \\end{array} } \\right] = \\log{\\bf P} in block matrix notation where {\\bf V} and {\\bf P} are the arrays of volume and pressure data, respectively. The other parameters in the system are taken from CAD or empirically determined by comparing logged data from prescribed motion between simulation and the physical test bench.","title":"Determining Parameter Values"},{"location":"theory/#tether-forces","text":"","title":"Tether Forces"},{"location":"theory/#mooring-forces","text":"","title":"Mooring Forces"},{"location":"theory/#ocean-wave-forces","text":"","title":"Ocean Wave Forces"},{"location":"tutorials/","text":"Installation Install (from source) Install (Docker) Running the Simulator Run the Simulator View Tutorials/ROS 2 Messages View Messages with Plotjuggler Simulator Output Data Logs Adjust Simulator parameters Control Simulator with pbcmd Adding Control Code Tutorials/ROS 2 Messages and Services Controller GitHub Template (Python) Controller GitHub Template (C++) Linear Damper Example (Python) Linear Damper Example (C++) Open-Loop Control Example Closed-Loop Control Example Model-Predictive Control Example","title":"Tutorials"},{"location":"tutorials/#installation","text":"Install (from source) Install (Docker)","title":"Installation"},{"location":"tutorials/#running-the-simulator","text":"Run the Simulator View Tutorials/ROS 2 Messages View Messages with Plotjuggler Simulator Output Data Logs Adjust Simulator parameters Control Simulator with pbcmd","title":"Running the Simulator"},{"location":"tutorials/#adding-control-code","text":"Tutorials/ROS 2 Messages and Services Controller GitHub Template (Python) Controller GitHub Template (C++) Linear Damper Example (Python) Linear Damper Example (C++) Open-Loop Control Example Closed-Loop Control Example Model-Predictive Control Example","title":"Adding Control Code"},{"location":"Tutorials/Install/Install_docker/","text":"Docker images that include the neccessary software and dependencies have been created for convenience. Requirements Install Docker using installation instructions. . Install nvidia-docker . Complete the Linux Postinstall steps to allow you to manage Docker as a non-root user. Install rocker by sudo apt-get install python3-rocker . Usage Clone the buoy_entrypoint repository to download the latest Dockerfile. $ git clone https://github.com/osrf/buoy_entrypoint.git $ cd ~/buoy_entrypoint/docker/ Build the docker image $ ./build.bash buoy Run the container $ ./run.bash [-d|s] buoy:latest where `./run.bash` option: * -d Use for development with host system volume mount * -s Simulation purposes only The development use case enables to either use host system home directory for user's custom workspace, or a fresh clone inside the docker container. If using host system workspace, follow the [On Host System](#on-host-system) instructions to build and run the project in the container. Regardless the script option, project source files can be found in `/tmp/buoy_ws/' in the container. Note that any changes to files in the container will have limited scope. To have another window running the same docker container, run this command in a new terminal: $ ./join.bash buoy_latest_runtime The build and run bash scripts are a wrapper around rocker, checkout its documentation for additional options. Run an example to test Inside the docker container, run: $ gz sim mbari_wec.sdf -r The simulation software should now be available. To run and test, proceed to the Run the Simulator tutorial series.","title":"Install docker"},{"location":"Tutorials/Install/Install_docker/#requirements","text":"Install Docker using installation instructions. . Install nvidia-docker . Complete the Linux Postinstall steps to allow you to manage Docker as a non-root user. Install rocker by sudo apt-get install python3-rocker .","title":"Requirements"},{"location":"Tutorials/Install/Install_docker/#usage","text":"Clone the buoy_entrypoint repository to download the latest Dockerfile. $ git clone https://github.com/osrf/buoy_entrypoint.git $ cd ~/buoy_entrypoint/docker/ Build the docker image $ ./build.bash buoy Run the container $ ./run.bash [-d|s] buoy:latest where `./run.bash` option: * -d Use for development with host system volume mount * -s Simulation purposes only The development use case enables to either use host system home directory for user's custom workspace, or a fresh clone inside the docker container. If using host system workspace, follow the [On Host System](#on-host-system) instructions to build and run the project in the container. Regardless the script option, project source files can be found in `/tmp/buoy_ws/' in the container. Note that any changes to files in the container will have limited scope. To have another window running the same docker container, run this command in a new terminal: $ ./join.bash buoy_latest_runtime The build and run bash scripts are a wrapper around rocker, checkout its documentation for additional options.","title":"Usage"},{"location":"Tutorials/Install/Install_docker/#run-an-example-to-test","text":"Inside the docker container, run: $ gz sim mbari_wec.sdf -r The simulation software should now be available. To run and test, proceed to the Run the Simulator tutorial series.","title":"Run an example to test"},{"location":"Tutorials/Install/Install_source/","text":"Install Requirements Use Ubuntu 22.04. Install ROS 2 Humble Buoy Sim is tested against the cyclonedds rmw implementation, so set that up as follows: sudo apt install -y ros-humble-rmw-cyclonedds-cpp export RMW_IMPLEMENTATION=rmw_cyclonedds_cpp Install Gazebo Garden Install necessary tools $ sudo apt install python3-vcstool python3-colcon-common-extensions python3-pip git wget Buoy Simulation Software Build Create a workspace, for example: $ mkdir -p ~/buoy_ws/src $ cd ~/buoy_ws/src Clone all source repos with the help of vcstool : $ wget https://raw.githubusercontent.com/osrf/buoy_entrypoint/main/buoy_all.yaml $ vcs import < buoy_all.yaml $ cd ~/buoy_ws Set the Gazebo version to Garden. This is needed because we're not using an official ROS + Gazebo combination: $ export GZ_VERSION=garden Install ROS dependencies $ sudo pip3 install -U rosdep $ sudo rosdep init $ rosdep update $ rosdep install --from-paths src --ignore-src -r -y -i Build and install $ source /opt/ros/humble/setup.bash $ cd ~/buoy_ws $ colcon build The simulation software should build without errors. To run and test, proceed to the Run the Simulator tutorial series. Or run a quick test as described below to confirm all has worked as expected. Run an example to test In a new terminal, source the workspace $ . ~/buoy_ws/install/setup.sh` Launch the simulation $ ros2 launch buoy_gazebo mbari_wec.launch.py`","title":"Install source"},{"location":"Tutorials/Install/Install_source/#install-requirements","text":"Use Ubuntu 22.04. Install ROS 2 Humble Buoy Sim is tested against the cyclonedds rmw implementation, so set that up as follows: sudo apt install -y ros-humble-rmw-cyclonedds-cpp export RMW_IMPLEMENTATION=rmw_cyclonedds_cpp Install Gazebo Garden Install necessary tools $ sudo apt install python3-vcstool python3-colcon-common-extensions python3-pip git wget","title":"Install Requirements"},{"location":"Tutorials/Install/Install_source/#buoy-simulation-software-build","text":"Create a workspace, for example: $ mkdir -p ~/buoy_ws/src $ cd ~/buoy_ws/src Clone all source repos with the help of vcstool : $ wget https://raw.githubusercontent.com/osrf/buoy_entrypoint/main/buoy_all.yaml $ vcs import < buoy_all.yaml $ cd ~/buoy_ws Set the Gazebo version to Garden. This is needed because we're not using an official ROS + Gazebo combination: $ export GZ_VERSION=garden Install ROS dependencies $ sudo pip3 install -U rosdep $ sudo rosdep init $ rosdep update $ rosdep install --from-paths src --ignore-src -r -y -i Build and install $ source /opt/ros/humble/setup.bash $ cd ~/buoy_ws $ colcon build The simulation software should build without errors. To run and test, proceed to the Run the Simulator tutorial series. Or run a quick test as described below to confirm all has worked as expected.","title":"Buoy Simulation Software Build"},{"location":"Tutorials/Install/Install_source/#run-an-example-to-test","text":"In a new terminal, source the workspace $ . ~/buoy_ws/install/setup.sh` Launch the simulation $ ros2 launch buoy_gazebo mbari_wec.launch.py`","title":"Run an example to test"},{"location":"Tutorials/ROS2/CPPTemplate/","text":"Quick Start \u2014 Writing External Controller With GitHub Template Repository In this tutorial, you will make and customize a GitHub repository from a GitHub Template with a ROS 2 C++ package and code ready to implement your own external controller utilizing the buoy_api_cpp interface. This interface may be used with the both the simulated and physical buoy. Interfaces and Templates There are two GitHub template repositories set up (C++/Python) for a quick start on writing a custom controller utilizing buoy_api_cpp and buoy_api_py . Please see C++ examples and Python examples for example controller implementations. mbari_wec_template_cpp mbari_wec_template_py Using C++ Template Creating your own repo from the template You may also refer to GitHub's template documentation To start using the C++ GitHub template Navigate to mbari_wec_template_cpp and click the green button with the text Use this template and select Create a new repository Next, set up the repository like you would any new GitHub repository choosing the owner, repository name, public/private, etc. Make a ROS 2 workspace $ mkdir -p ~/controller_ws/src $ cd ~/controller_ws/src Now that your new repository is set up, clone it to your local machine, make a branch, etc. $ git clone https://github.com/<owner>/<repo_name>.git $ cd ~/controller_ws You should now have a C++ ROS 2 package with the following structure in your workspace src : <repo_name> \u251c\u2500\u2500 CMakeLists.txt \u251c\u2500\u2500 config \u2502 \u2514\u2500\u2500 controller.yaml \u251c\u2500\u2500 include \u2502 \u2514\u2500\u2500 mbari_wec_template_cpp \u2502 \u251c\u2500\u2500 controller.hpp \u2502 \u2514\u2500\u2500 control_policy.hpp \u251c\u2500\u2500 launch \u2502 \u2514\u2500\u2500 controller.launch.py \u251c\u2500\u2500 LICENSE \u251c\u2500\u2500 package.xml \u251c\u2500\u2500 README.md \u2514\u2500\u2500 src \u2514\u2500\u2500 controller.cpp Customizing the controller You may also refer to the README.md in your newly cloned repository. Modify template for your package Replace mbari_wec_template_cpp with your package name and modify other fields as necessary in: package.xml (lines 4-8) package.xml 1 2 3 4 5 6 7 8 <?xml version=\"1.0\"?> <?xml-model href=\"http://download.ros.org/schema/package_format3.xsd\" schematypens=\"http://www.w3.org/2001/XMLSchema\"?> <package format= \"3\" > <name> repo_name </name> <!-- Update package name --> <version> 3.14 </version> <!-- Update version --> <description> Your Controller Description </description> <!-- Update description --> <maintainer email= \"your@email\" > Your Name </maintainer> <!-- Update email and name --> <license> Your License </license> <!-- Update license --> CMakeLists.txt (line 2) CMakeLists.txt 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 cmake_minimum_required ( VERSION 3.8 ) project ( mbari_wec_template_cpp ) # Update ${PROJECT_NAME} if ( CMAKE_COMPILER_IS_GNUCXX OR CMAKE_CXX_COMPILER_ID MATCHES \"Clang\" ) add_compile_options ( -Wall -Wextra -Wpedantic ) endif () # find dependencies find_package ( ament_cmake REQUIRED ) find_package ( rclcpp REQUIRED ) find_package ( buoy_interfaces REQUIRED ) find_package ( buoy_api_cpp REQUIRED COMPONENTS buoy_api ) add_executable ( ${ PROJECT_NAME } src/controller.cpp ) target_link_libraries ( ${ PROJECT_NAME } PUBLIC buoy_api_cpp::buoy_api ) ament_target_dependencies ( ${ PROJECT_NAME } PUBLIC rclcpp buoy_interfaces ) target_include_directories ( ${ PROJECT_NAME } PUBLIC $< BUILD_INTERFACE:${CMAKE_CURRENT_SOURCE_DIR}/include > $< INSTALL_INTERFACE:include > ) target_compile_features ( ${ PROJECT_NAME } PUBLIC c_std_99 cxx_std_17 ) # Require C99 and C++17 launch/controller.launch.py (line 22) launch/controller.launch.py 22 23 24 25 26 27 28 29 30 31 32 33 34 35 package_name = 'your_package_name' # Update package name (same as in CMakeLists.txt) def generate_launch_description (): ld = LaunchDescription () config = os . path . join ( get_package_share_directory ( package_name ), 'config' , 'controller.yaml' ) node = Node ( package = package_name , name = package_name , # ensure same as name in config.yaml executable = package_name , config/controller.yaml (line 1) Update first line with your controller name (same as node name in launch file) config/controller.yaml 1 2 3 /your_controller_name : ros__parameters : foo : 1.0 and rename the folder: include/mbari_wec_template_cpp (containing controller.hpp and control_policy.hpp ) to your package name resulting in the following folder structure: <your_package_name> \u251c\u2500\u2500 CMakeLists.txt \u251c\u2500\u2500 config \u2502 \u2514\u2500\u2500 controller.yaml \u251c\u2500\u2500 include \u2502 \u2514\u2500\u2500 <your_package_name> \u2502 \u251c\u2500\u2500 controller.hpp \u2502 \u2514\u2500\u2500 control_policy.hpp \u251c\u2500\u2500 launch \u2502 \u2514\u2500\u2500 controller.launch.py \u251c\u2500\u2500 LICENSE \u251c\u2500\u2500 package.xml \u251c\u2500\u2500 README.md \u2514\u2500\u2500 src \u2514\u2500\u2500 controller.cpp Update the include paths in: controller.cpp (lines 18-19) src/controller.cpp 18 19 #include <mbari_wec_template_cpp/control_policy.hpp> // update include path #include <mbari_wec_template_cpp/controller.hpp> // update include path control_policy.hpp (line 22) include/your_package_name/control_policy.hpp 22 #include <mbari_wec_template_cpp/controller.hpp> // update include path Also, update include guards: control_policy.hpp include/your_package_name/control_policy.hpp 15 16 #ifndef YOUR_PACKAGE_NAME__CONTROL_POLICY_HPP_ #define YOUR_PACKAGE_NAME__CONTROL_POLICY_HPP_ ... \u200b 67 #endif // YOUR_PACKAGE_NAME__CONTROL_POLICY_HPP_ controller.hpp include/your_package_name/controller.hpp 15 16 #ifndef YOUR_PACKAGE_NAME__CONTROLLER_HPP_ #define YOUR_PACKAGE_NAME__CONTROLLER_HPP_ ... \u200b 74 #endif // YOUR_PACKAGE_NAME__CONTROLLER_HPP_ Modify CMakeLists.txt as desired and add any dependencies in package.xml following standard ROS 2 documentation. Implement Controller Assuming you have followed the above, include/<your_package_name>/control_policy.hpp src/controller.cpp are stubbed out to implement your custom external controller. You may also use config/controller.yaml for any policy parameters. ControlPolicy You may use the struct ControlPolicy in control_policy.hpp to implement your controller. include/your_package_name/control_policy.hpp 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 struct ControlPolicy { // declare/init any parameter variables here double foo { 1.0 }; double bar { 10.0 * foo }; ControlPolicy () : foo { 1.0 }, bar { 10.0 * foo } { update_params (); } // Update dependent variables after reading in params void update_params () { bar = 10.0 * foo ; } // Modify function inputs as desired // Calculate target value from feedback inputs double target ( const double & /*some*/ , const double & /*feedback*/ , const double & /*values*/ ) { // secret sauce return 0.0 ; // obviously, modify to return proper target value } }; Declare/define any configurable parameters in the struct and init list include/your_package_name/control_policy.hpp 27 28 29 30 31 32 33 // declare/init any parameter variables here double foo { 1.0 }; double bar { 10.0 * foo }; ControlPolicy () : foo { 1.0 }, bar { 10.0 * foo } Set any dependent variables in update_params on line 39 include/your_package_name/control_policy.hpp 38 39 40 41 42 // Update dependent variables after reading in params void update_params () { bar = 10.0 * foo ; } Declare/get/update params in the set_params function of the Controller class on line 58 include/your_package_name/control_policy.hpp 58 59 60 61 62 63 64 65 66 // Use ROS2 declare_parameter and get_parameter to set policy params void Controller::set_params () { this -> declare_parameter ( \"foo\" , policy_ -> foo ); policy_ -> foo = this -> get_parameter ( \"foo\" ). as_double (); // recompute any dependent variables policy_ -> update_params (); } Then, your control logic will go in the target function on line 46. Modify the input args as well as the return value as necessary include/your_package_name/control_policy.hpp 44 45 46 47 48 49 50 51 52 53 54 55 // Modify function inputs as desired // Calculate target value from feedback inputs double target ( const double & /*some*/ , const double & /*feedback*/ , const double & /*values*/ ) { // secret sauce return 0.0 ; // obviously, modify to return proper target value } Controller The Controller class contains an instance of ControlPolicy as the member variable, this->policy . The this->policy->target function may be called anywhere within the Controller class. You may call it inside any of the data callbacks to enable feedback control (for example): (EXAMPLE) include/your_package_name/controller.hpp // To subscribe to any topic, simply declare & define the specific callback, e.g. power_callback // Callback for '/power_data' topic from Power Controller void power_callback ( const buoy_interfaces :: msg :: PCRecord & data ) { // get target value from control policy double wind_curr = policy_ -> target ( data . rpm , data . scale , data . retract ); auto future = this -> send_pc_wind_curr_command ( wind_curr ); } Or, set up a loop in main and run open-loop: (EXAMPLE) src/controller.cpp int main ( int argc , char ** argv ) { rclcpp :: init ( argc , argv ); auto controller = std :: make_shared < Controller > ( \"controller\" ); rclcpp :: Rate rate ( 50.0 ); while ( rclcpp :: ok ()) { rclcpp :: spin_once ( controller ); rate . sleep (); } rclcpp :: shutdown (); return 0 ; } You may get feedback data from any of the buoy topics by simply creating a specific callback listed below. For feedback data you'd like to use in another area of the class, feel free to assign them to class variables. (Delete any callbacks you don't need in the Controller class) Available callback functions: /ahrs_data \u2192 void ahrs_callback(const buoy_interfaces::msg::XBRecord & data){} /battery_data \u2192 void battery_callback(const buoy_interfaces::msg::BCRecord & data){} /spring_data \u2192 void spring_callback(const buoy_interfaces::msg::SCRecord & data){} /power_data \u2192 void power_callback(const buoy_interfaces::msg::PCRecord & data){} /trefoil_data \u2192 void trefoil_callback(const buoy_interfaces::msg::TFRecord & data){} /powerbuoy_data \u2192 void powerbuoy_callback(const buoy_interfaces::msg::PBRecord & data){} You may also send commands from within the Controller class: this->send_pump_command(duration_mins); this->send_valve_command(duration_sec); this->send_pc_wind_curr_command(wind_curr_amps); this->send_pc_bias_curr_command(bias_curr_amps); this->send_pc_scale_command(scale_factor); this->send_pc_retract_command(retract_factor); In the Controller constructor, you may also uncomment lines 31 or 32 to set the publish rates for the Spring or Power Controllers on the buoy. These controllers default to publishing feedback at 10Hz to conserve data/bandwidth (on the physical buoy). For feedback control, you have the option to increase the publish rate. You can call commands to set the rates anywhere from 10Hz to 50Hz (default argument is 50Hz). src/controller.cpp 22 23 24 25 26 27 28 29 30 31 32 33 Controller :: Controller ( const std :: string & node_name ) : buoy_api :: Interface < Controller > ( node_name ), policy_ ( std :: make_unique < ControlPolicy > ()) { this -> set_params (); // set packet rates from controllers here // controller defaults to publishing @ 10Hz // call these to set rate to 50Hz or provide argument for specific rate // this->set_sc_pack_rate_param(); // set SC publish rate to 50Hz // this->set_pc_pack_rate_param(); // set PC publish rate to 50Hz } Build, Test, Run At this point, your new package should build, pass tests, and run against the sim (will connect but do nothing). It is assumed that you have already installed or built the buoy packages. From your workspace (e.g. ~/controller_ws ) build your package: $ colcon build Starting >>> mbari_wec_template_cpp Finished <<< mbari_wec_template_cpp [25.0s] Summary: 1 package finished [25.2s] You may also build only your new controller package (if you have other packages in the workspace) using: $ colcon build --packages-up-to <your_package_name> Then, source and test: $ source install/local_setup.bash $ colcon test Starting >>> mbari_wec_template_cpp Finished <<< mbari_wec_template_cpp [1.38s] Summary: 1 package finished [1.54s] Or, you may test only your new controller package using: $ colcon test --packages-select <your_package_name> Next, in another terminal run the sim (after sourcing the sim packages of course): $ ros2 launch buoy_gazebo mbari_wec.launch.py Now, in the previous terminal, launch the empty controller: $ ros2 launch <your_package_name> controller.launch.py And you should see something similar to: [INFO] [launch]: Default logging verbosity is set to INFO [INFO] [mbari_wec_template_cpp-1]: process started with pid [1297902] [mbari_wec_template_cpp-1] [INFO] [1678127525.594948064] [mbari_wec_template_cpp]: Subscribing to XBRecord on '/ahrs_data' and '/xb_record' [mbari_wec_template_cpp-1] [INFO] [1678127525.595508167] [mbari_wec_template_cpp]: Subscribing to BCRecord on '/battery_data' and '/bc_record' [mbari_wec_template_cpp-1] [INFO] [1678127525.595795098] [mbari_wec_template_cpp]: Subscribing to SCRecord on '/spring_data' and '/sc_record' [mbari_wec_template_cpp-1] [INFO] [1678127525.596027219] [mbari_wec_template_cpp]: Subscribing to PCRecord on '/power_data' and '/pc_record' [mbari_wec_template_cpp-1] [INFO] [1678127525.596275007] [mbari_wec_template_cpp]: Subscribing to TFRecord on '/trefoil_data' and '/tf_record' [mbari_wec_template_cpp-1] [INFO] [1678127525.596593805] [mbari_wec_template_cpp]: Subscribing to PBRecord on '/powerbuoy_data' [mbari_wec_template_cpp-1] [INFO] [1678127525.697067297] [mbari_wec_template_cpp]: /pc_pack_rate_command not available [mbari_wec_template_cpp-1] [INFO] [1678127525.797309937] [mbari_wec_template_cpp]: /sc_pack_rate_command not available [mbari_wec_template_cpp-1] [INFO] [1678127525.797524439] [mbari_wec_template_cpp]: Found all required services. Example An example using this interface will follow in the next tutorial: Linear Damper Example (C++)","title":"Quick Start &mdash; Writing External Controller With GitHub Template Repository"},{"location":"Tutorials/ROS2/CPPTemplate/#quick-start-writing-external-controller-with-github-template-repository","text":"In this tutorial, you will make and customize a GitHub repository from a GitHub Template with a ROS 2 C++ package and code ready to implement your own external controller utilizing the buoy_api_cpp interface. This interface may be used with the both the simulated and physical buoy.","title":"Quick Start &mdash; Writing External Controller With GitHub Template Repository"},{"location":"Tutorials/ROS2/CPPTemplate/#interfaces-and-templates","text":"There are two GitHub template repositories set up (C++/Python) for a quick start on writing a custom controller utilizing buoy_api_cpp and buoy_api_py . Please see C++ examples and Python examples for example controller implementations. mbari_wec_template_cpp mbari_wec_template_py","title":"Interfaces and Templates"},{"location":"Tutorials/ROS2/CPPTemplate/#using-c-template","text":"","title":"Using C++ Template"},{"location":"Tutorials/ROS2/CPPTemplate/#creating-your-own-repo-from-the-template","text":"You may also refer to GitHub's template documentation To start using the C++ GitHub template Navigate to mbari_wec_template_cpp and click the green button with the text Use this template and select Create a new repository Next, set up the repository like you would any new GitHub repository choosing the owner, repository name, public/private, etc. Make a ROS 2 workspace $ mkdir -p ~/controller_ws/src $ cd ~/controller_ws/src Now that your new repository is set up, clone it to your local machine, make a branch, etc. $ git clone https://github.com/<owner>/<repo_name>.git $ cd ~/controller_ws You should now have a C++ ROS 2 package with the following structure in your workspace src : <repo_name> \u251c\u2500\u2500 CMakeLists.txt \u251c\u2500\u2500 config \u2502 \u2514\u2500\u2500 controller.yaml \u251c\u2500\u2500 include \u2502 \u2514\u2500\u2500 mbari_wec_template_cpp \u2502 \u251c\u2500\u2500 controller.hpp \u2502 \u2514\u2500\u2500 control_policy.hpp \u251c\u2500\u2500 launch \u2502 \u2514\u2500\u2500 controller.launch.py \u251c\u2500\u2500 LICENSE \u251c\u2500\u2500 package.xml \u251c\u2500\u2500 README.md \u2514\u2500\u2500 src \u2514\u2500\u2500 controller.cpp","title":"Creating your own repo from the template"},{"location":"Tutorials/ROS2/CPPTemplate/#customizing-the-controller","text":"You may also refer to the README.md in your newly cloned repository.","title":"Customizing the controller"},{"location":"Tutorials/ROS2/CPPTemplate/#modify-template-for-your-package","text":"Replace mbari_wec_template_cpp with your package name and modify other fields as necessary in: package.xml (lines 4-8) package.xml 1 2 3 4 5 6 7 8 <?xml version=\"1.0\"?> <?xml-model href=\"http://download.ros.org/schema/package_format3.xsd\" schematypens=\"http://www.w3.org/2001/XMLSchema\"?> <package format= \"3\" > <name> repo_name </name> <!-- Update package name --> <version> 3.14 </version> <!-- Update version --> <description> Your Controller Description </description> <!-- Update description --> <maintainer email= \"your@email\" > Your Name </maintainer> <!-- Update email and name --> <license> Your License </license> <!-- Update license --> CMakeLists.txt (line 2) CMakeLists.txt 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 cmake_minimum_required ( VERSION 3.8 ) project ( mbari_wec_template_cpp ) # Update ${PROJECT_NAME} if ( CMAKE_COMPILER_IS_GNUCXX OR CMAKE_CXX_COMPILER_ID MATCHES \"Clang\" ) add_compile_options ( -Wall -Wextra -Wpedantic ) endif () # find dependencies find_package ( ament_cmake REQUIRED ) find_package ( rclcpp REQUIRED ) find_package ( buoy_interfaces REQUIRED ) find_package ( buoy_api_cpp REQUIRED COMPONENTS buoy_api ) add_executable ( ${ PROJECT_NAME } src/controller.cpp ) target_link_libraries ( ${ PROJECT_NAME } PUBLIC buoy_api_cpp::buoy_api ) ament_target_dependencies ( ${ PROJECT_NAME } PUBLIC rclcpp buoy_interfaces ) target_include_directories ( ${ PROJECT_NAME } PUBLIC $< BUILD_INTERFACE:${CMAKE_CURRENT_SOURCE_DIR}/include > $< INSTALL_INTERFACE:include > ) target_compile_features ( ${ PROJECT_NAME } PUBLIC c_std_99 cxx_std_17 ) # Require C99 and C++17 launch/controller.launch.py (line 22) launch/controller.launch.py 22 23 24 25 26 27 28 29 30 31 32 33 34 35 package_name = 'your_package_name' # Update package name (same as in CMakeLists.txt) def generate_launch_description (): ld = LaunchDescription () config = os . path . join ( get_package_share_directory ( package_name ), 'config' , 'controller.yaml' ) node = Node ( package = package_name , name = package_name , # ensure same as name in config.yaml executable = package_name , config/controller.yaml (line 1) Update first line with your controller name (same as node name in launch file) config/controller.yaml 1 2 3 /your_controller_name : ros__parameters : foo : 1.0 and rename the folder: include/mbari_wec_template_cpp (containing controller.hpp and control_policy.hpp ) to your package name resulting in the following folder structure: <your_package_name> \u251c\u2500\u2500 CMakeLists.txt \u251c\u2500\u2500 config \u2502 \u2514\u2500\u2500 controller.yaml \u251c\u2500\u2500 include \u2502 \u2514\u2500\u2500 <your_package_name> \u2502 \u251c\u2500\u2500 controller.hpp \u2502 \u2514\u2500\u2500 control_policy.hpp \u251c\u2500\u2500 launch \u2502 \u2514\u2500\u2500 controller.launch.py \u251c\u2500\u2500 LICENSE \u251c\u2500\u2500 package.xml \u251c\u2500\u2500 README.md \u2514\u2500\u2500 src \u2514\u2500\u2500 controller.cpp Update the include paths in: controller.cpp (lines 18-19) src/controller.cpp 18 19 #include <mbari_wec_template_cpp/control_policy.hpp> // update include path #include <mbari_wec_template_cpp/controller.hpp> // update include path control_policy.hpp (line 22) include/your_package_name/control_policy.hpp 22 #include <mbari_wec_template_cpp/controller.hpp> // update include path Also, update include guards: control_policy.hpp include/your_package_name/control_policy.hpp 15 16 #ifndef YOUR_PACKAGE_NAME__CONTROL_POLICY_HPP_ #define YOUR_PACKAGE_NAME__CONTROL_POLICY_HPP_ ... \u200b 67 #endif // YOUR_PACKAGE_NAME__CONTROL_POLICY_HPP_ controller.hpp include/your_package_name/controller.hpp 15 16 #ifndef YOUR_PACKAGE_NAME__CONTROLLER_HPP_ #define YOUR_PACKAGE_NAME__CONTROLLER_HPP_ ... \u200b 74 #endif // YOUR_PACKAGE_NAME__CONTROLLER_HPP_ Modify CMakeLists.txt as desired and add any dependencies in package.xml following standard ROS 2 documentation.","title":"Modify template for your package"},{"location":"Tutorials/ROS2/CPPTemplate/#implement-controller","text":"Assuming you have followed the above, include/<your_package_name>/control_policy.hpp src/controller.cpp are stubbed out to implement your custom external controller. You may also use config/controller.yaml for any policy parameters.","title":"Implement Controller"},{"location":"Tutorials/ROS2/CPPTemplate/#controlpolicy","text":"You may use the struct ControlPolicy in control_policy.hpp to implement your controller. include/your_package_name/control_policy.hpp 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 struct ControlPolicy { // declare/init any parameter variables here double foo { 1.0 }; double bar { 10.0 * foo }; ControlPolicy () : foo { 1.0 }, bar { 10.0 * foo } { update_params (); } // Update dependent variables after reading in params void update_params () { bar = 10.0 * foo ; } // Modify function inputs as desired // Calculate target value from feedback inputs double target ( const double & /*some*/ , const double & /*feedback*/ , const double & /*values*/ ) { // secret sauce return 0.0 ; // obviously, modify to return proper target value } }; Declare/define any configurable parameters in the struct and init list include/your_package_name/control_policy.hpp 27 28 29 30 31 32 33 // declare/init any parameter variables here double foo { 1.0 }; double bar { 10.0 * foo }; ControlPolicy () : foo { 1.0 }, bar { 10.0 * foo } Set any dependent variables in update_params on line 39 include/your_package_name/control_policy.hpp 38 39 40 41 42 // Update dependent variables after reading in params void update_params () { bar = 10.0 * foo ; } Declare/get/update params in the set_params function of the Controller class on line 58 include/your_package_name/control_policy.hpp 58 59 60 61 62 63 64 65 66 // Use ROS2 declare_parameter and get_parameter to set policy params void Controller::set_params () { this -> declare_parameter ( \"foo\" , policy_ -> foo ); policy_ -> foo = this -> get_parameter ( \"foo\" ). as_double (); // recompute any dependent variables policy_ -> update_params (); } Then, your control logic will go in the target function on line 46. Modify the input args as well as the return value as necessary include/your_package_name/control_policy.hpp 44 45 46 47 48 49 50 51 52 53 54 55 // Modify function inputs as desired // Calculate target value from feedback inputs double target ( const double & /*some*/ , const double & /*feedback*/ , const double & /*values*/ ) { // secret sauce return 0.0 ; // obviously, modify to return proper target value }","title":"ControlPolicy"},{"location":"Tutorials/ROS2/CPPTemplate/#controller","text":"The Controller class contains an instance of ControlPolicy as the member variable, this->policy . The this->policy->target function may be called anywhere within the Controller class. You may call it inside any of the data callbacks to enable feedback control (for example): (EXAMPLE) include/your_package_name/controller.hpp // To subscribe to any topic, simply declare & define the specific callback, e.g. power_callback // Callback for '/power_data' topic from Power Controller void power_callback ( const buoy_interfaces :: msg :: PCRecord & data ) { // get target value from control policy double wind_curr = policy_ -> target ( data . rpm , data . scale , data . retract ); auto future = this -> send_pc_wind_curr_command ( wind_curr ); } Or, set up a loop in main and run open-loop: (EXAMPLE) src/controller.cpp int main ( int argc , char ** argv ) { rclcpp :: init ( argc , argv ); auto controller = std :: make_shared < Controller > ( \"controller\" ); rclcpp :: Rate rate ( 50.0 ); while ( rclcpp :: ok ()) { rclcpp :: spin_once ( controller ); rate . sleep (); } rclcpp :: shutdown (); return 0 ; } You may get feedback data from any of the buoy topics by simply creating a specific callback listed below. For feedback data you'd like to use in another area of the class, feel free to assign them to class variables. (Delete any callbacks you don't need in the Controller class) Available callback functions: /ahrs_data \u2192 void ahrs_callback(const buoy_interfaces::msg::XBRecord & data){} /battery_data \u2192 void battery_callback(const buoy_interfaces::msg::BCRecord & data){} /spring_data \u2192 void spring_callback(const buoy_interfaces::msg::SCRecord & data){} /power_data \u2192 void power_callback(const buoy_interfaces::msg::PCRecord & data){} /trefoil_data \u2192 void trefoil_callback(const buoy_interfaces::msg::TFRecord & data){} /powerbuoy_data \u2192 void powerbuoy_callback(const buoy_interfaces::msg::PBRecord & data){} You may also send commands from within the Controller class: this->send_pump_command(duration_mins); this->send_valve_command(duration_sec); this->send_pc_wind_curr_command(wind_curr_amps); this->send_pc_bias_curr_command(bias_curr_amps); this->send_pc_scale_command(scale_factor); this->send_pc_retract_command(retract_factor); In the Controller constructor, you may also uncomment lines 31 or 32 to set the publish rates for the Spring or Power Controllers on the buoy. These controllers default to publishing feedback at 10Hz to conserve data/bandwidth (on the physical buoy). For feedback control, you have the option to increase the publish rate. You can call commands to set the rates anywhere from 10Hz to 50Hz (default argument is 50Hz). src/controller.cpp 22 23 24 25 26 27 28 29 30 31 32 33 Controller :: Controller ( const std :: string & node_name ) : buoy_api :: Interface < Controller > ( node_name ), policy_ ( std :: make_unique < ControlPolicy > ()) { this -> set_params (); // set packet rates from controllers here // controller defaults to publishing @ 10Hz // call these to set rate to 50Hz or provide argument for specific rate // this->set_sc_pack_rate_param(); // set SC publish rate to 50Hz // this->set_pc_pack_rate_param(); // set PC publish rate to 50Hz }","title":"Controller"},{"location":"Tutorials/ROS2/CPPTemplate/#build-test-run","text":"At this point, your new package should build, pass tests, and run against the sim (will connect but do nothing). It is assumed that you have already installed or built the buoy packages. From your workspace (e.g. ~/controller_ws ) build your package: $ colcon build Starting >>> mbari_wec_template_cpp Finished <<< mbari_wec_template_cpp [25.0s] Summary: 1 package finished [25.2s] You may also build only your new controller package (if you have other packages in the workspace) using: $ colcon build --packages-up-to <your_package_name> Then, source and test: $ source install/local_setup.bash $ colcon test Starting >>> mbari_wec_template_cpp Finished <<< mbari_wec_template_cpp [1.38s] Summary: 1 package finished [1.54s] Or, you may test only your new controller package using: $ colcon test --packages-select <your_package_name> Next, in another terminal run the sim (after sourcing the sim packages of course): $ ros2 launch buoy_gazebo mbari_wec.launch.py Now, in the previous terminal, launch the empty controller: $ ros2 launch <your_package_name> controller.launch.py And you should see something similar to: [INFO] [launch]: Default logging verbosity is set to INFO [INFO] [mbari_wec_template_cpp-1]: process started with pid [1297902] [mbari_wec_template_cpp-1] [INFO] [1678127525.594948064] [mbari_wec_template_cpp]: Subscribing to XBRecord on '/ahrs_data' and '/xb_record' [mbari_wec_template_cpp-1] [INFO] [1678127525.595508167] [mbari_wec_template_cpp]: Subscribing to BCRecord on '/battery_data' and '/bc_record' [mbari_wec_template_cpp-1] [INFO] [1678127525.595795098] [mbari_wec_template_cpp]: Subscribing to SCRecord on '/spring_data' and '/sc_record' [mbari_wec_template_cpp-1] [INFO] [1678127525.596027219] [mbari_wec_template_cpp]: Subscribing to PCRecord on '/power_data' and '/pc_record' [mbari_wec_template_cpp-1] [INFO] [1678127525.596275007] [mbari_wec_template_cpp]: Subscribing to TFRecord on '/trefoil_data' and '/tf_record' [mbari_wec_template_cpp-1] [INFO] [1678127525.596593805] [mbari_wec_template_cpp]: Subscribing to PBRecord on '/powerbuoy_data' [mbari_wec_template_cpp-1] [INFO] [1678127525.697067297] [mbari_wec_template_cpp]: /pc_pack_rate_command not available [mbari_wec_template_cpp-1] [INFO] [1678127525.797309937] [mbari_wec_template_cpp]: /sc_pack_rate_command not available [mbari_wec_template_cpp-1] [INFO] [1678127525.797524439] [mbari_wec_template_cpp]: Found all required services.","title":"Build, Test, Run"},{"location":"Tutorials/ROS2/CPPTemplate/#example","text":"An example using this interface will follow in the next tutorial: Linear Damper Example (C++)","title":"Example"},{"location":"Tutorials/ROS2/ClosedLoopControl/","text":"","title":"ClosedLoopControl"},{"location":"Tutorials/ROS2/CppLinearDamperExample/","text":"","title":"CppLinearDamperExample"},{"location":"Tutorials/ROS2/MPC/","text":"","title":"MPC"},{"location":"Tutorials/ROS2/MessagesAndServices/","text":"","title":"MessagesAndServices"},{"location":"Tutorials/ROS2/OpenLoopControl/","text":"","title":"OpenLoopControl"},{"location":"Tutorials/ROS2/PythonLinearDamperExample/","text":"Quick Start -- Simple Linear Damper Controller (Python) Prerequisite This tutorial assumes you have followed the steps from the previous tutorial on creating and customizing your own Python ROS 2 controller package from the mbari_wec_template_py template repository. To begin, you should have a Python ROS 2 controller package that looks similar to: mbari_wec_linear_damper_py \u251c\u2500\u2500 config \u2502 \u2514\u2500\u2500 controller.yaml \u251c\u2500\u2500 CONTRIBUTING.md \u251c\u2500\u2500 launch \u2502 \u2514\u2500\u2500 controller.launch.py \u251c\u2500\u2500 LICENSE \u251c\u2500\u2500 mbari_wec_linear_damper_py \u2502 \u251c\u2500\u2500 controller.py \u2502 \u251c\u2500\u2500 __init__.py \u251c\u2500\u2500 package.xml \u251c\u2500\u2500 README.md \u251c\u2500\u2500 resource \u2502 \u2514\u2500\u2500 mbari_wec_linear_damper_py \u251c\u2500\u2500 setup.cfg \u251c\u2500\u2500 setup.py \u2514\u2500\u2500 test \u251c\u2500\u2500 test_copyright.py \u251c\u2500\u2500 test_flake8.py \u2514\u2500\u2500 test_pep257.py with the files modified from the previous tutorial. If haven't already, follow the steps in the above mentioned link to create a package for this tutorial named mbari_wec_linear_damper_py . Linear Damper ControlPolicy In this tutorial you will implement a simple linear damper controller for the piston in the WEC Power-Take-Off (PTO). Given motor RPM, it outputs desired motor winding current (interpolated from RPM->Torque lookup table) to generate a torque to resist piston velocity with a damping force. Configurable gains (scale/retract factor) are applied before output. In the end, you will have a working linear damper controller that is very close to the controller running on both the physical and simulated buoy. A full example starting from the template may be found here . Line numbers in this tutorial corresponds to the lines in relevant files in the full example. Parameters Parameters for the controller are: torque_constant : Motor Torque Constant (N-m/Amp) Constant to convert desired torque to applied motor winding current n_spec : Input Motor Speed (RPM) Breakpoints N (RPM) is the input to the controller and n_spec are the x-components of the breakpoints \\left(n\\_spec, \\frac{torque\\_spec}{torque_constant}\\right) for the interpolant, \\hat{f}_{I}(n\\_spec) = \\frac{torque\\_spec}{torque\\_constant} \\approx f_{I}(N) = I torque_spec : Desired Output Motor Torque (N-m) Breakpoints Torque (N-m) is the eventual desired output of the controller given an input N (motor RPM) and torque_spec / torque_constant (Amps) are the y-components of the breakpoints for the interpolant. The controller actually outputs motor winding current (Amps) to generate a torque in the opposite direction of piston velocity to generate a damping force. These can be configured using the config/controller.yaml file. config/controller.yaml 1 2 3 4 5 /linear_damper : ros__parameters : torque_constant : 0.438 n_spec : [ 0.0 , 300.0 , 600.0 , 1000.0 , 1700.0 , 4400.0 , 6790.0 ] torque_spec : [ 0.0 , 0.0 , 0.8 , 2.9 , 5.6 , 9.8 , 16.6 ] As you can see, as motor speed increases, so does the damping torque. For low RPM (up to 300), there is no damping. Initialize these variables in ControlPolicy in mbari_wec_linear_damper_py/controller.py . This example makes use of numpy.array . mbari_wec_linear_damper_py/controller.py 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 class ControlPolicy ( object ): \"\"\" Simple Linear Damper Control Policy. Implements a simple linear damper controller for the piston in the WEC Power-Take-Off (PTO). Given motor RPM, outputs desired motor winding current (interpolated from RPM->Torque lookup table) to resist piston velocity. Configurable gains (scale/retract factor) are applied before output. \"\"\" def __init__ ( self ): # Define any parameter variables here self . Torque_constant = 0.438 # N-m/Amps # Desired damping Torque vs RPM relationship self . N_Spec = np . array ([ 0.0 , 300.0 , 600.0 , 1000.0 , 1700.0 , 4400.0 , 6790.0 ]) # RPM self . Torque_Spec = np . array ([ 0.0 , 0.0 , 0.8 , 2.9 , 5.6 , 9.8 , 16.6 ]) # N-m Update the dependent variable, I_Spec , and create the interpolator, windcurr_interp1d , which uses interp1d from scipy.interpolate . mbari_wec_linear_damper_py/controller.py 43 44 45 46 47 48 49 def update_params ( self ): \"\"\"Update dependent variables after reading in params.\"\"\" # Convert to Motor Winding Current vs RPM and generate interpolator for f(RPM) = I self . I_Spec = self . Torque_Spec / self . Torque_constant # Amps self . windcurr_interp1d = interpolate . interp1d ( self . N_Spec , self . I_Spec , fill_value = self . I_Spec [ - 1 ], bounds_error = False ) Finally, in the Controller class, declare/get/set/update these parameters from ROS 2 (as set in config/controller.yaml ). mbari_wec_linear_damper_py/controller.py 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 def set_params ( self ): \"\"\"Use ROS2 declare_parameter and get_parameter to set policy params.\"\"\" self . declare_parameter ( 'torque_constant' , self . policy . Torque_constant ) self . policy . Torque_constant = \\ self . get_parameter ( 'torque_constant' ) . get_parameter_value () . double_value self . declare_parameter ( 'n_spec' , self . policy . N_Spec . tolist ()) self . policy . N_Spec = \\ np . array ( self . get_parameter ( 'n_spec' ) . get_parameter_value () . double_array_value ) self . declare_parameter ( 'torque_spec' , self . policy . Torque_Spec . tolist ()) self . policy . Torque_Spec = \\ np . array ( self . get_parameter ( 'torque_spec' ) . get_parameter_value () . double_array_value ) # recompute any dependent variables self . policy . update_params () self . get_logger () . info ( str ( self . policy )) The example includes a helper function, __str__ , in the ControlPolicy class to report the parameters used. mbari_wec_linear_damper_py/controller.py 66 67 68 69 70 71 72 73 74 def __str__ ( self ): return \"\"\"ControlPolicy: \\t Torque_constant: {tc} \\t N_Spec: {nspec} \\t Torque_Spec: {tspec} \\t I_Spec: {ispec} \"\"\" . format ( tc = self . Torque_constant , nspec = self . N_Spec , tspec = self . Torque_Spec , ispec = self . I_Spec ) Control Policy Target To implement the torque control control policy, we use the target function in ControlPolicy . This is where we accept feedback data and return a command value. In this case, we need the motor rpm , and the gains applied to the winding current damping, scale_factor and retract_factor . Typical values for these gains are scale_factor = 1 retract_factor = 0.6 mbari_wec_linear_damper_py/controller.py 52 53 54 55 56 57 58 59 60 61 62 63 64 def target ( self , rpm , scale_factor , retract_factor ): \"\"\"Calculate target value from feedback inputs.\"\"\" N = abs ( rpm ) I = self . windcurr_interp1d ( N ) # Apply damping gain I *= scale_factor # Hysteresis due to gravity assist if rpm > 0.0 : I *= - retract_factor return float ( I ) So, as you can see we apply a positive damping torque when N is negative (piston extending), and a positive damping torque when N is positive (piston retracting). The damping torque required is reduced when retracting. Controller All that is left is to connect the necessary feedback data to the ControlPolicy . In this case, rpm , scale , and retract are present in buoy_interfaces.msg.PCRecord on the /power_data topic published by the Power Controller running on the buoy. To access the data, all that is required is to define the callback def power_callback(self, data) in the Controller class, and pass the data to self.policy.target to get the desired winding current command. Various commands are available, and this time we will be using self.send_pc_wind_curr_command(wind_curr, blocking=False) mbari_wec_linear_damper_py/controller.py 107 108 109 110 111 112 113 114 115 116 def power_callback ( self , data ): \"\"\"Provide feedback of '/power_data' topic from Power Controller.\"\"\" # Update class variables, get control policy target, send commands, etc. wind_curr = self . policy . target ( data . rpm , data . scale , data . retract ) self . get_logger () . info ( 'WindingCurrent:' + f ' f( { data . rpm : .02f } , { data . scale : .02f } , { data . retract : .02f } )' + f ' = { wind_curr : .02f } ' ) self . send_pc_wind_curr_command ( wind_curr , blocking = False ) Finally, let's set the Power Controller's publish rate to the maximum of 50Hz. Uncomment the line to set the PC Pack Rate in Controller.__init__ : mbari_wec_linear_damper_py/controller.py 79 80 81 82 83 84 85 86 87 88 def __init__ ( self ): super () . __init__ ( 'linear_damper' ) self . policy = ControlPolicy () self . set_params () # set packet rates from controllers here # controller defaults to publishing feedback @ 10Hz # call these to set rate to 50Hz or provide argument for specific rate self . set_pc_pack_rate_param () # set PC feedback publish rate to 50Hz Try It Out We will be using ros2 launch and launch/controller.launch.py to run our new controller. To run the controller along with the simulation, first source your workspace. Then, launch your controller: $ ros2 launch mbari_wec_linear_damper_py controller.launch.py Then, launch the sim: $ ros2 launch buoy_gazebo mbari_wec.launch.py and click the play button. You should see output similar to: [linear_damper-1] [INFO] [1677864397.617058507] [linear_damper]: Found all required services. [linear_damper-1] [INFO] [1677864397.618426488] [linear_damper]: ControlPolicy: [linear_damper-1] Torque_constant: 0.438 [linear_damper-1] N_Spec: [ 0. 300. 600. 1000. 1700. 4400. 6790.] [linear_damper-1] Torque_Spec: [ 0. 0. 0.8 2.9 5.6 9.8 16.6] [linear_damper-1] I_Spec: [ 0. 0. 1.82648402 6.62100457 12.78538813 22.37442922 [linear_damper-1] 37.89954338] [linear_damper-1] [INFO] [1677864197.432679525] [linear_damper]: WindingCurrent: f(4962.91, 1.00, 0.60) = -15.62 [linear_damper-1] [INFO] [1677864197.532727531] [linear_damper]: WindingCurrent: f(7764.73, 1.00, 0.60) = -22.74 [linear_damper-1] [INFO] [1677864197.632748699] [linear_damper]: WindingCurrent: f(10504.88, 1.00, 0.60) = -22.74 [linear_damper-1] [INFO] [1677864197.732851121] [linear_damper]: WindingCurrent: f(11491.33, 1.00, 0.60) = -22.74 [linear_damper-1] [INFO] [1677864197.833078440] [linear_damper]: WindingCurrent: f(11075.84, 1.00, 0.60) = -22.74 [linear_damper-1] [INFO] [1677864197.933050356] [linear_damper]: WindingCurrent: f(9546.51, 1.00, 0.60) = -22.74 [linear_damper-1] [INFO] [1677864198.033185882] [linear_damper]: WindingCurrent: f(7499.68, 1.00, 0.60) = -22.74 [linear_damper-1] [INFO] [1677864198.133197926] [linear_damper]: WindingCurrent: f(5190.35, 1.00, 0.60) = -16.51 [linear_damper-1] [INFO] [1677864198.233322713] [linear_damper]: WindingCurrent: f(2353.02, 1.00, 0.60) = -9.06 [linear_damper-1] [INFO] [1677864198.333507127] [linear_damper]: WindingCurrent: f(-257.59, 1.00, 0.60) = 0.00 [linear_damper-1] [INFO] [1677864198.433489830] [linear_damper]: WindingCurrent: f(-2185.58, 1.00, 0.60) = 14.51 [linear_damper-1] [INFO] [1677864198.533538450] [linear_damper]: WindingCurrent: f(-2987.98, 1.00, 0.60) = 17.36 [linear_damper-1] [INFO] [1677864198.633671249] [linear_damper]: WindingCurrent: f(-3513.15, 1.00, 0.60) = 19.22 [linear_damper-1] [INFO] [1677864198.733703803] [linear_damper]: WindingCurrent: f(-3738.12, 1.00, 0.60) = 20.02 [linear_damper-1] [INFO] [1677864198.833889518] [linear_damper]: WindingCurrent: f(-3751.64, 1.00, 0.60) = 20.07 [linear_damper-1] [INFO] [1677864198.933993414] [linear_damper]: WindingCurrent: f(-3595.71, 1.00, 0.60) = 19.52 [linear_damper-1] [INFO] [1677864199.034078009] [linear_damper]: WindingCurrent: f(-3306.87, 1.00, 0.60) = 18.49 [linear_damper-1] [INFO] [1677864199.134273438] [linear_damper]: WindingCurrent: f(-3012.52, 1.00, 0.60) = 17.45 [linear_damper-1] [INFO] [1677864199.234371669] [linear_damper]: WindingCurrent: f(-2617.97, 1.00, 0.60) = 16.05 [linear_damper-1] [INFO] [1677864199.334275962] [linear_damper]: WindingCurrent: f(-2269.58, 1.00, 0.60) = 14.81 [linear_damper-1] [INFO] [1677864199.434369620] [linear_damper]: WindingCurrent: f(-1893.56, 1.00, 0.60) = 13.47 [linear_damper-1] [INFO] [1677864199.534461914] [linear_damper]: WindingCurrent: f(-1513.34, 1.00, 0.60) = 11.14 [linear_damper-1] [INFO] [1677864199.634556815] [linear_damper]: WindingCurrent: f(-1128.46, 1.00, 0.60) = 7.75 [linear_damper-1] [INFO] [1677864199.734798736] [linear_damper]: WindingCurrent: f(-825.91, 1.00, 0.60) = 4.53 [linear_damper-1] [INFO] [1677864199.834753871] [linear_damper]: WindingCurrent: f(-586.78, 1.00, 0.60) = 1.75 [linear_damper-1] [INFO] [1677864199.934809041] [linear_damper]: WindingCurrent: f(-393.25, 1.00, 0.60) = 0.57 [linear_damper-1] [INFO] [1677864200.035109715] [linear_damper]: WindingCurrent: f(-132.04, 1.00, 0.60) = 0.00 [linear_damper-1] [INFO] [1677864200.134981992] [linear_damper]: WindingCurrent: f(92.19, 1.00, 0.60) = -0.00 [linear_damper-1] [INFO] [1677864200.235094219] [linear_damper]: WindingCurrent: f(338.10, 1.00, 0.60) = -0.14 [linear_damper-1] [INFO] [1677864200.335164181] [linear_damper]: WindingCurrent: f(636.96, 1.00, 0.60) = -1.36 [linear_damper-1] [INFO] [1677864200.435227880] [linear_damper]: WindingCurrent: f(863.33, 1.00, 0.60) = -2.99","title":"Quick Start -- Simple Linear Damper Controller (Python)"},{"location":"Tutorials/ROS2/PythonLinearDamperExample/#quick-start-simple-linear-damper-controller-python","text":"","title":"Quick Start -- Simple Linear Damper Controller (Python)"},{"location":"Tutorials/ROS2/PythonLinearDamperExample/#prerequisite","text":"This tutorial assumes you have followed the steps from the previous tutorial on creating and customizing your own Python ROS 2 controller package from the mbari_wec_template_py template repository. To begin, you should have a Python ROS 2 controller package that looks similar to: mbari_wec_linear_damper_py \u251c\u2500\u2500 config \u2502 \u2514\u2500\u2500 controller.yaml \u251c\u2500\u2500 CONTRIBUTING.md \u251c\u2500\u2500 launch \u2502 \u2514\u2500\u2500 controller.launch.py \u251c\u2500\u2500 LICENSE \u251c\u2500\u2500 mbari_wec_linear_damper_py \u2502 \u251c\u2500\u2500 controller.py \u2502 \u251c\u2500\u2500 __init__.py \u251c\u2500\u2500 package.xml \u251c\u2500\u2500 README.md \u251c\u2500\u2500 resource \u2502 \u2514\u2500\u2500 mbari_wec_linear_damper_py \u251c\u2500\u2500 setup.cfg \u251c\u2500\u2500 setup.py \u2514\u2500\u2500 test \u251c\u2500\u2500 test_copyright.py \u251c\u2500\u2500 test_flake8.py \u2514\u2500\u2500 test_pep257.py with the files modified from the previous tutorial. If haven't already, follow the steps in the above mentioned link to create a package for this tutorial named mbari_wec_linear_damper_py .","title":"Prerequisite"},{"location":"Tutorials/ROS2/PythonLinearDamperExample/#linear-damper-controlpolicy","text":"In this tutorial you will implement a simple linear damper controller for the piston in the WEC Power-Take-Off (PTO). Given motor RPM, it outputs desired motor winding current (interpolated from RPM->Torque lookup table) to generate a torque to resist piston velocity with a damping force. Configurable gains (scale/retract factor) are applied before output. In the end, you will have a working linear damper controller that is very close to the controller running on both the physical and simulated buoy. A full example starting from the template may be found here . Line numbers in this tutorial corresponds to the lines in relevant files in the full example.","title":"Linear Damper ControlPolicy"},{"location":"Tutorials/ROS2/PythonLinearDamperExample/#parameters","text":"Parameters for the controller are: torque_constant : Motor Torque Constant (N-m/Amp) Constant to convert desired torque to applied motor winding current n_spec : Input Motor Speed (RPM) Breakpoints N (RPM) is the input to the controller and n_spec are the x-components of the breakpoints \\left(n\\_spec, \\frac{torque\\_spec}{torque_constant}\\right) for the interpolant, \\hat{f}_{I}(n\\_spec) = \\frac{torque\\_spec}{torque\\_constant} \\approx f_{I}(N) = I torque_spec : Desired Output Motor Torque (N-m) Breakpoints Torque (N-m) is the eventual desired output of the controller given an input N (motor RPM) and torque_spec / torque_constant (Amps) are the y-components of the breakpoints for the interpolant. The controller actually outputs motor winding current (Amps) to generate a torque in the opposite direction of piston velocity to generate a damping force. These can be configured using the config/controller.yaml file. config/controller.yaml 1 2 3 4 5 /linear_damper : ros__parameters : torque_constant : 0.438 n_spec : [ 0.0 , 300.0 , 600.0 , 1000.0 , 1700.0 , 4400.0 , 6790.0 ] torque_spec : [ 0.0 , 0.0 , 0.8 , 2.9 , 5.6 , 9.8 , 16.6 ] As you can see, as motor speed increases, so does the damping torque. For low RPM (up to 300), there is no damping. Initialize these variables in ControlPolicy in mbari_wec_linear_damper_py/controller.py . This example makes use of numpy.array . mbari_wec_linear_damper_py/controller.py 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 class ControlPolicy ( object ): \"\"\" Simple Linear Damper Control Policy. Implements a simple linear damper controller for the piston in the WEC Power-Take-Off (PTO). Given motor RPM, outputs desired motor winding current (interpolated from RPM->Torque lookup table) to resist piston velocity. Configurable gains (scale/retract factor) are applied before output. \"\"\" def __init__ ( self ): # Define any parameter variables here self . Torque_constant = 0.438 # N-m/Amps # Desired damping Torque vs RPM relationship self . N_Spec = np . array ([ 0.0 , 300.0 , 600.0 , 1000.0 , 1700.0 , 4400.0 , 6790.0 ]) # RPM self . Torque_Spec = np . array ([ 0.0 , 0.0 , 0.8 , 2.9 , 5.6 , 9.8 , 16.6 ]) # N-m Update the dependent variable, I_Spec , and create the interpolator, windcurr_interp1d , which uses interp1d from scipy.interpolate . mbari_wec_linear_damper_py/controller.py 43 44 45 46 47 48 49 def update_params ( self ): \"\"\"Update dependent variables after reading in params.\"\"\" # Convert to Motor Winding Current vs RPM and generate interpolator for f(RPM) = I self . I_Spec = self . Torque_Spec / self . Torque_constant # Amps self . windcurr_interp1d = interpolate . interp1d ( self . N_Spec , self . I_Spec , fill_value = self . I_Spec [ - 1 ], bounds_error = False ) Finally, in the Controller class, declare/get/set/update these parameters from ROS 2 (as set in config/controller.yaml ). mbari_wec_linear_damper_py/controller.py 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 def set_params ( self ): \"\"\"Use ROS2 declare_parameter and get_parameter to set policy params.\"\"\" self . declare_parameter ( 'torque_constant' , self . policy . Torque_constant ) self . policy . Torque_constant = \\ self . get_parameter ( 'torque_constant' ) . get_parameter_value () . double_value self . declare_parameter ( 'n_spec' , self . policy . N_Spec . tolist ()) self . policy . N_Spec = \\ np . array ( self . get_parameter ( 'n_spec' ) . get_parameter_value () . double_array_value ) self . declare_parameter ( 'torque_spec' , self . policy . Torque_Spec . tolist ()) self . policy . Torque_Spec = \\ np . array ( self . get_parameter ( 'torque_spec' ) . get_parameter_value () . double_array_value ) # recompute any dependent variables self . policy . update_params () self . get_logger () . info ( str ( self . policy )) The example includes a helper function, __str__ , in the ControlPolicy class to report the parameters used. mbari_wec_linear_damper_py/controller.py 66 67 68 69 70 71 72 73 74 def __str__ ( self ): return \"\"\"ControlPolicy: \\t Torque_constant: {tc} \\t N_Spec: {nspec} \\t Torque_Spec: {tspec} \\t I_Spec: {ispec} \"\"\" . format ( tc = self . Torque_constant , nspec = self . N_Spec , tspec = self . Torque_Spec , ispec = self . I_Spec )","title":"Parameters"},{"location":"Tutorials/ROS2/PythonLinearDamperExample/#control-policy-target","text":"To implement the torque control control policy, we use the target function in ControlPolicy . This is where we accept feedback data and return a command value. In this case, we need the motor rpm , and the gains applied to the winding current damping, scale_factor and retract_factor . Typical values for these gains are scale_factor = 1 retract_factor = 0.6 mbari_wec_linear_damper_py/controller.py 52 53 54 55 56 57 58 59 60 61 62 63 64 def target ( self , rpm , scale_factor , retract_factor ): \"\"\"Calculate target value from feedback inputs.\"\"\" N = abs ( rpm ) I = self . windcurr_interp1d ( N ) # Apply damping gain I *= scale_factor # Hysteresis due to gravity assist if rpm > 0.0 : I *= - retract_factor return float ( I ) So, as you can see we apply a positive damping torque when N is negative (piston extending), and a positive damping torque when N is positive (piston retracting). The damping torque required is reduced when retracting.","title":"Control Policy Target"},{"location":"Tutorials/ROS2/PythonLinearDamperExample/#controller","text":"All that is left is to connect the necessary feedback data to the ControlPolicy . In this case, rpm , scale , and retract are present in buoy_interfaces.msg.PCRecord on the /power_data topic published by the Power Controller running on the buoy. To access the data, all that is required is to define the callback def power_callback(self, data) in the Controller class, and pass the data to self.policy.target to get the desired winding current command. Various commands are available, and this time we will be using self.send_pc_wind_curr_command(wind_curr, blocking=False) mbari_wec_linear_damper_py/controller.py 107 108 109 110 111 112 113 114 115 116 def power_callback ( self , data ): \"\"\"Provide feedback of '/power_data' topic from Power Controller.\"\"\" # Update class variables, get control policy target, send commands, etc. wind_curr = self . policy . target ( data . rpm , data . scale , data . retract ) self . get_logger () . info ( 'WindingCurrent:' + f ' f( { data . rpm : .02f } , { data . scale : .02f } , { data . retract : .02f } )' + f ' = { wind_curr : .02f } ' ) self . send_pc_wind_curr_command ( wind_curr , blocking = False ) Finally, let's set the Power Controller's publish rate to the maximum of 50Hz. Uncomment the line to set the PC Pack Rate in Controller.__init__ : mbari_wec_linear_damper_py/controller.py 79 80 81 82 83 84 85 86 87 88 def __init__ ( self ): super () . __init__ ( 'linear_damper' ) self . policy = ControlPolicy () self . set_params () # set packet rates from controllers here # controller defaults to publishing feedback @ 10Hz # call these to set rate to 50Hz or provide argument for specific rate self . set_pc_pack_rate_param () # set PC feedback publish rate to 50Hz","title":"Controller"},{"location":"Tutorials/ROS2/PythonLinearDamperExample/#try-it-out","text":"We will be using ros2 launch and launch/controller.launch.py to run our new controller. To run the controller along with the simulation, first source your workspace. Then, launch your controller: $ ros2 launch mbari_wec_linear_damper_py controller.launch.py Then, launch the sim: $ ros2 launch buoy_gazebo mbari_wec.launch.py and click the play button. You should see output similar to: [linear_damper-1] [INFO] [1677864397.617058507] [linear_damper]: Found all required services. [linear_damper-1] [INFO] [1677864397.618426488] [linear_damper]: ControlPolicy: [linear_damper-1] Torque_constant: 0.438 [linear_damper-1] N_Spec: [ 0. 300. 600. 1000. 1700. 4400. 6790.] [linear_damper-1] Torque_Spec: [ 0. 0. 0.8 2.9 5.6 9.8 16.6] [linear_damper-1] I_Spec: [ 0. 0. 1.82648402 6.62100457 12.78538813 22.37442922 [linear_damper-1] 37.89954338] [linear_damper-1] [INFO] [1677864197.432679525] [linear_damper]: WindingCurrent: f(4962.91, 1.00, 0.60) = -15.62 [linear_damper-1] [INFO] [1677864197.532727531] [linear_damper]: WindingCurrent: f(7764.73, 1.00, 0.60) = -22.74 [linear_damper-1] [INFO] [1677864197.632748699] [linear_damper]: WindingCurrent: f(10504.88, 1.00, 0.60) = -22.74 [linear_damper-1] [INFO] [1677864197.732851121] [linear_damper]: WindingCurrent: f(11491.33, 1.00, 0.60) = -22.74 [linear_damper-1] [INFO] [1677864197.833078440] [linear_damper]: WindingCurrent: f(11075.84, 1.00, 0.60) = -22.74 [linear_damper-1] [INFO] [1677864197.933050356] [linear_damper]: WindingCurrent: f(9546.51, 1.00, 0.60) = -22.74 [linear_damper-1] [INFO] [1677864198.033185882] [linear_damper]: WindingCurrent: f(7499.68, 1.00, 0.60) = -22.74 [linear_damper-1] [INFO] [1677864198.133197926] [linear_damper]: WindingCurrent: f(5190.35, 1.00, 0.60) = -16.51 [linear_damper-1] [INFO] [1677864198.233322713] [linear_damper]: WindingCurrent: f(2353.02, 1.00, 0.60) = -9.06 [linear_damper-1] [INFO] [1677864198.333507127] [linear_damper]: WindingCurrent: f(-257.59, 1.00, 0.60) = 0.00 [linear_damper-1] [INFO] [1677864198.433489830] [linear_damper]: WindingCurrent: f(-2185.58, 1.00, 0.60) = 14.51 [linear_damper-1] [INFO] [1677864198.533538450] [linear_damper]: WindingCurrent: f(-2987.98, 1.00, 0.60) = 17.36 [linear_damper-1] [INFO] [1677864198.633671249] [linear_damper]: WindingCurrent: f(-3513.15, 1.00, 0.60) = 19.22 [linear_damper-1] [INFO] [1677864198.733703803] [linear_damper]: WindingCurrent: f(-3738.12, 1.00, 0.60) = 20.02 [linear_damper-1] [INFO] [1677864198.833889518] [linear_damper]: WindingCurrent: f(-3751.64, 1.00, 0.60) = 20.07 [linear_damper-1] [INFO] [1677864198.933993414] [linear_damper]: WindingCurrent: f(-3595.71, 1.00, 0.60) = 19.52 [linear_damper-1] [INFO] [1677864199.034078009] [linear_damper]: WindingCurrent: f(-3306.87, 1.00, 0.60) = 18.49 [linear_damper-1] [INFO] [1677864199.134273438] [linear_damper]: WindingCurrent: f(-3012.52, 1.00, 0.60) = 17.45 [linear_damper-1] [INFO] [1677864199.234371669] [linear_damper]: WindingCurrent: f(-2617.97, 1.00, 0.60) = 16.05 [linear_damper-1] [INFO] [1677864199.334275962] [linear_damper]: WindingCurrent: f(-2269.58, 1.00, 0.60) = 14.81 [linear_damper-1] [INFO] [1677864199.434369620] [linear_damper]: WindingCurrent: f(-1893.56, 1.00, 0.60) = 13.47 [linear_damper-1] [INFO] [1677864199.534461914] [linear_damper]: WindingCurrent: f(-1513.34, 1.00, 0.60) = 11.14 [linear_damper-1] [INFO] [1677864199.634556815] [linear_damper]: WindingCurrent: f(-1128.46, 1.00, 0.60) = 7.75 [linear_damper-1] [INFO] [1677864199.734798736] [linear_damper]: WindingCurrent: f(-825.91, 1.00, 0.60) = 4.53 [linear_damper-1] [INFO] [1677864199.834753871] [linear_damper]: WindingCurrent: f(-586.78, 1.00, 0.60) = 1.75 [linear_damper-1] [INFO] [1677864199.934809041] [linear_damper]: WindingCurrent: f(-393.25, 1.00, 0.60) = 0.57 [linear_damper-1] [INFO] [1677864200.035109715] [linear_damper]: WindingCurrent: f(-132.04, 1.00, 0.60) = 0.00 [linear_damper-1] [INFO] [1677864200.134981992] [linear_damper]: WindingCurrent: f(92.19, 1.00, 0.60) = -0.00 [linear_damper-1] [INFO] [1677864200.235094219] [linear_damper]: WindingCurrent: f(338.10, 1.00, 0.60) = -0.14 [linear_damper-1] [INFO] [1677864200.335164181] [linear_damper]: WindingCurrent: f(636.96, 1.00, 0.60) = -1.36 [linear_damper-1] [INFO] [1677864200.435227880] [linear_damper]: WindingCurrent: f(863.33, 1.00, 0.60) = -2.99","title":"Try It Out"},{"location":"Tutorials/ROS2/PythonTemplate/","text":"Quick Start \u2014 Writing External Controller With GitHub Template Repository In this tutorial, you will make and customize a GitHub repository from a GitHub Template with a ROS 2 Python package and code ready to implement your own external controller utilizing the buoy_api_py interface. This interface may be used with the both the simulated and physical buoy. Interfaces and Templates There are two GitHub template repositories set up (C++/Python) for a quick start on writing a custom controller utilizing buoy_api_cpp and buoy_api_py . Please see C++ examples and Python examples for example controller implementations. mbari_wec_template_cpp mbari_wec_template_py Using Python Template Creating your own repo from the template You may also refer to GitHub's template documentation To start using the Python GitHub template Navigate to mbari_wec_template_py and click the green button with the text Use this template and select Create a new repository Next, set up the repository like you would any new GitHub repository choosing the owner, repository name, public/private, etc. Make a ROS 2 workspace $ mkdir -p ~/controller_ws/src $ cd ~/controller_ws/src Now that your new repository is set up, clone it to your local machine, make a branch, etc. $ git clone https://github.com/<owner>/<repo_name>.git $ cd ~/controller_ws You should now have a Python ROS 2 package with the following structure: <repo_name> \u251c\u2500\u2500 config \u2502 \u2514\u2500\u2500 controller.yaml \u251c\u2500\u2500 launch \u2502 \u2514\u2500\u2500 controller.launch.py \u251c\u2500\u2500 LICENSE \u251c\u2500\u2500 mbari_wec_template_py \u2502 \u251c\u2500\u2500 controller.py \u2502 \u2514\u2500\u2500 __init__.py \u251c\u2500\u2500 package.xml \u251c\u2500\u2500 README.md \u251c\u2500\u2500 resource \u2502 \u2514\u2500\u2500 mbari_wec_template_py \u251c\u2500\u2500 setup.cfg \u251c\u2500\u2500 setup.py \u2514\u2500\u2500 test \u251c\u2500\u2500 test_copyright.py \u251c\u2500\u2500 test_flake8.py \u2514\u2500\u2500 test_pep257.py Customizing the controller You may also refer to the README.md in your newly cloned repository. Modify template for your package Replace mbari_wec_template_py with your package name and modify other fields as necessary in: package.xml (lines 4-8) package.xml 1 2 3 4 5 6 7 8 <?xml version=\"1.0\"?> <?xml-model href=\"http://download.ros.org/schema/package_format3.xsd\" schematypens=\"http://www.w3.org/2001/XMLSchema\"?> <package format= \"3\" > <name> repo_name </name> <!-- Update package name --> <version> 3.14 </version> <!-- Update version --> <description> Your Controller Description </description> <!-- Update description --> <maintainer email= \"your@email\" > Your Name </maintainer> <!-- Update email and name --> <license> Your License </license> <!-- Update license --> setup.py (lines 7, 11, 22-25, 29) setup.py 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 package_name = 'your_package_name' # Update package name setup ( name = package_name , version = '3.14' , # Update version packages = [ f ' { package_name } ' ], data_files = [ ( 'share/ament_index/resource_index/packages' , [ 'resource/' + package_name ]), ( 'share/' + package_name , [ 'package.xml' ]), ( os . path . join ( 'share' , package_name , 'launch' ), glob ( 'launch/*.launch.py' )), ( os . path . join ( 'share' , package_name , 'config' ), glob ( 'config/*.yaml' )) ], install_requires = [ 'setuptools' ], zip_safe = True , maintainer = 'Your Name' , # Update name maintainer_email = 'your@email' , # Update email description = 'Your package description' , # Update package description license = 'Your License' , # Update license tests_require = [ 'pytest' ], entry_points = { 'console_scripts' : [ f 'your_controller_name = { package_name } .controller:main' , # Update controller executable name setup.cfg (lines 2, 4) Update script_dir and install_scripts locations with your package name setup.cfg 1 2 3 4 [develop] script_dir = $base/lib/your_package_name [install] install_scripts = $base/lib/your_package_name launch/controller.launch.py (lines 22, 35-36) launch/controller.launch.py 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 package_name = 'your_package_name' # Update package name def generate_launch_description (): ld = LaunchDescription () config = os . path . join ( get_package_share_directory ( package_name ), 'config' , 'controller.yaml' ) node = Node ( package = package_name , name = 'your_controller_name' , # Update controller name (same as name in config.yaml) executable = 'your_controller_name' , # Update controller executable name from setup.py config/controller.yaml (line 1) Update first line with your controller name (same as node name in launch file) config/controller.yaml 1 2 3 /your_controller_name : ros__parameters : foo : 1.0 and rename two files/folders the empty file resource/mbari_wec_template_py the Python package mbari_wec_template_py containing controller.py resulting in the following folder structure: repo_name \u251c\u2500\u2500 config \u2502 \u2514\u2500\u2500 controller.yaml \u251c\u2500\u2500 launch \u2502 \u2514\u2500\u2500 controller.launch.py \u251c\u2500\u2500 LICENSE \u251c\u2500\u2500 your_package_name \u2502 \u251c\u2500\u2500 controller.py \u2502 \u2514\u2500\u2500 __init__.py \u251c\u2500\u2500 package.xml \u251c\u2500\u2500 README.md \u251c\u2500\u2500 resource \u2502 \u2514\u2500\u2500 your_package_name \u251c\u2500\u2500 setup.cfg \u251c\u2500\u2500 setup.py \u2514\u2500\u2500 test \u251c\u2500\u2500 test_copyright.py \u251c\u2500\u2500 test_flake8.py \u2514\u2500\u2500 test_pep257.py Modify setup.py as desired and add any dependencies in package.xml following standard ROS 2 documentation. Implement Controller Assuming you have followed the above and renamed the Python package mbari_wec_template_py to your package name, <your_package_name>/controller.py is stubbed out to implement your custom external controller. You may also use config/controller.yaml for any policy parameters. ControlPolicy You may use the class ControlPolicy in <your_package_name>/controller.py to implement your controller. 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 class ControlPolicy ( object ): def __init__ ( self ): # Define any parameter variables here self . foo = 1.0 self . update_params () def update_params ( self ): \"\"\"Update dependent variables after reading in params.\"\"\" self . bar = 10.0 * self . foo pass # remove if there's anything to set above # Modify function inputs as desired def target ( self , * args , ** kwargs ): \"\"\"Calculate target value from feedback inputs.\"\"\" # secret sauce return 0.0 # obviously, modify to return proper target value Set any configurable parameters in __init__ on line 23 23 24 25 26 27 def __init__ ( self ): # Define any parameter variables here self . foo = 1.0 self . update_params () Set any dependent variables in update_params on line 29 29 30 31 32 33 def update_params ( self ): \"\"\"Update dependent variables after reading in params.\"\"\" self . bar = 10.0 * self . foo pass # remove if there's anything to set above Declare/get/update params in the set_params function of the Controller class on line 113 113 114 115 116 117 118 119 120 def set_params ( self ): \"\"\"Use ROS2 declare_parameter and get_parameter to set policy params.\"\"\" self . declare_parameter ( 'foo' , self . policy . foo ) self . policy . foo = \\ self . get_parameter ( 'foo' ) . get_parameter_value () . double_value # recompute any dependent variables self . policy . update_params () Then, your control logic will go in the target function on line 36. Modify the input args as well as the return value as necessary 35 36 37 38 39 40 41 # Modify function inputs as desired def target ( self , * args , ** kwargs ): # noqa: D202 \"\"\"Calculate target value from feedback inputs.\"\"\" # secret sauce return 0.0 # obviously, modify to return proper target value Controller The Controller class contains an instance of ControlPolicy as the member variable, self.policy . The self.policy.target function may be called anywhere within the Controller class. You may call it inside any of the data callbacks to enable feedback control (for example): # To subscribe to any topic, simply define the specific callback, e.g. power_callback def power_callback ( self , data ): '''Callback for '/power_data' topic from Power Controller''' # get target value from control policy target_value = self . policy . target ( data . rpm , data . scale , data . retract ) # send a command, e.g. winding current self . send_pc_wind_curr_command ( target_value , blocking = False ) Or, set up a loop in main() and run open-loop: 123 124 125 126 127 128 129 130 131 132 133 def main (): rclpy . init () controller = Controller () rate = controller . create_rate ( 50.0 ) # Hz while rclpy . ok (): # Open-loop control logic rclpy . spin_once ( controller ) rate . sleep () rclpy . shutdown () You may get feedback data from any of the buoy topics by simply creating a specific callback listed below. For feedback data you'd like to use in another area of the class, feel free to assign them to class variables. (Delete any callbacks you don't need in the Controller class) Available callback functions: /ahrs_data \u2192 def ahrs_callback(self, data): /battery_data \u2192 def battery_callback(self, data): /spring_data \u2192 def spring_callback(self, data): /power_data \u2192 def power_callback(self, data): /trefoil_data \u2192 def trefoil_callback(self, data): /powerbuoy_data \u2192 def powerbuoy_callback(self, data): You may also send commands from within the Controller class: self.send_pump_command(duration_mins, blocking=False) self.send_valve_command(duration_sec, blocking=False) self.send_pc_wind_curr_command(wind_curr_amps, blocking=False) self.send_pc_bias_curr_command(bias_curr_amps, blocking=False) self.send_pc_scale_command(scale_factor, blocking=False) self.send_pc_retract_command(retract_factor, blocking=False) In the Controller constructor, you may also uncomment lines 55 or 56 to set the publish rates for the Spring or Power Controllers on the buoy. These controllers default to publishing at 10Hz. You can call commands to set the rates anywhere from 10Hz to 50Hz (default argument is 50Hz). 46 47 48 49 50 51 52 53 54 55 56 def __init__ ( self ): super () . __init__ ( 'controller' ) self . policy = ControlPolicy () self . set_params () # set packet rates from controllers here # controller defaults to publishing @ 10Hz # call these to set rate to 50Hz or provide argument for specific rate # self.set_pc_pack_rate_param() # set PC publish rate to 50Hz # self.set_sc_pack_rate_param() # set SC publish rate to 50Hz Build, Test, Run At this point, your new package should build, pass tests, and run against the sim (will connect but do nothing). It is assumed that you have already installed or built the buoy packages. From your workspace (e.g. ~/controller_ws ) build your package: $ colcon build Starting >>> mbari_wec_template_py --- stderr: mbari_wec_template_py /usr/lib/python3/dist-packages/setuptools/command/install.py:34: SetuptoolsDeprecationWarning: setup.py install is deprecated. Use build and pip and other standards-based tools. warnings.warn( --- Finished <<< mbari_wec_template_py [0.74s] Summary: 1 package finished [0.89s] 1 package had stderr output: mbari_wec_template_py You may also build only your new controller package (if you have other packages in the workspace) using: $ colcon build --packages-up-to <your_package_name> Then, source and test: $ source install/local_setup.bash $ colcon test Starting >>> mbari_wec_template_py --- stderr: mbari_wec_template_py =============================== warnings summary =============================== test/test_flake8.py::test_flake8 test/test_flake8.py::test_flake8 Warning: SelectableGroups dict interface is deprecated. Use select. -- Docs: https://docs.pytest.org/en/stable/warnings.html --- Finished <<< mbari_wec_template_py [0.74s] Summary: 1 package finished [0.87s] 1 package had stderr output: mbari_wec_template_py Or, you may test only your new controller package using: $ colcon test --packages-select <your_package_name> Next, in another terminal run the sim (after sourcing the sim packages of course): $ ros2 launch buoy_gazebo mbari_wec.launch.py Now, in the previous terminal, launch the empty controller: $ ros2 launch <your_package_name> controller.launch.py And you should see something similar to: [INFO] [launch]: Default logging verbosity is set to INFO [INFO] [controller-1]: process started with pid [1409887] [controller-1] [INFO] [1678130539.867493131] [controller]: Subscribing to <class 'buoy_interfaces.msg._xb_record.XBRecord'> on '/ahrs_data' [controller-1] [INFO] [1678130540.031500810] [controller]: Subscribing to <class 'buoy_interfaces.msg._bc_record.BCRecord'> on '/battery_data' [controller-1] [INFO] [1678130540.031972332] [controller]: Subscribing to <class 'buoy_interfaces.msg._sc_record.SCRecord'> on '/spring_data' [controller-1] [INFO] [1678130540.032390456] [controller]: Subscribing to <class 'buoy_interfaces.msg._pc_record.PCRecord'> on '/power_data' [controller-1] [INFO] [1678130540.032810815] [controller]: Subscribing to <class 'buoy_interfaces.msg._tf_record.TFRecord'> on '/trefoil_data' [controller-1] [INFO] [1678130540.033268687] [controller]: Subscribing to <class 'buoy_interfaces.msg._xb_record.XBRecord'> on '/xb_record' [controller-1] [INFO] [1678130540.033703510] [controller]: Subscribing to <class 'buoy_interfaces.msg._bc_record.BCRecord'> on '/bc_record' [controller-1] [INFO] [1678130540.034091374] [controller]: Subscribing to <class 'buoy_interfaces.msg._sc_record.SCRecord'> on '/sc_record' [controller-1] [INFO] [1678130540.034467140] [controller]: Subscribing to <class 'buoy_interfaces.msg._pc_record.PCRecord'> on '/pc_record' [controller-1] [INFO] [1678130540.034868686] [controller]: Subscribing to <class 'buoy_interfaces.msg._tf_record.TFRecord'> on '/tf_record' [controller-1] [INFO] [1678130540.035298496] [controller]: Subscribing to <class 'buoy_interfaces.msg._pb_record.PBRecord'> on '/powerbuoy_data' [controller-1] [INFO] [1678130540.286577653] [controller]: /pc_pack_rate_command not available [controller-1] [INFO] [1678130540.537643441] [controller]: /sc_pack_rate_command not available [controller-1] [INFO] [1678130540.538230613] [controller]: Found all required services. Example An example using this interface will follow in the next tutorial: Linear Damper Example (Python)","title":"Quick Start &mdash; Writing External Controller With GitHub Template Repository"},{"location":"Tutorials/ROS2/PythonTemplate/#quick-start-writing-external-controller-with-github-template-repository","text":"In this tutorial, you will make and customize a GitHub repository from a GitHub Template with a ROS 2 Python package and code ready to implement your own external controller utilizing the buoy_api_py interface. This interface may be used with the both the simulated and physical buoy.","title":"Quick Start &mdash; Writing External Controller With GitHub Template Repository"},{"location":"Tutorials/ROS2/PythonTemplate/#interfaces-and-templates","text":"There are two GitHub template repositories set up (C++/Python) for a quick start on writing a custom controller utilizing buoy_api_cpp and buoy_api_py . Please see C++ examples and Python examples for example controller implementations. mbari_wec_template_cpp mbari_wec_template_py","title":"Interfaces and Templates"},{"location":"Tutorials/ROS2/PythonTemplate/#using-python-template","text":"","title":"Using Python Template"},{"location":"Tutorials/ROS2/PythonTemplate/#creating-your-own-repo-from-the-template","text":"You may also refer to GitHub's template documentation To start using the Python GitHub template Navigate to mbari_wec_template_py and click the green button with the text Use this template and select Create a new repository Next, set up the repository like you would any new GitHub repository choosing the owner, repository name, public/private, etc. Make a ROS 2 workspace $ mkdir -p ~/controller_ws/src $ cd ~/controller_ws/src Now that your new repository is set up, clone it to your local machine, make a branch, etc. $ git clone https://github.com/<owner>/<repo_name>.git $ cd ~/controller_ws You should now have a Python ROS 2 package with the following structure: <repo_name> \u251c\u2500\u2500 config \u2502 \u2514\u2500\u2500 controller.yaml \u251c\u2500\u2500 launch \u2502 \u2514\u2500\u2500 controller.launch.py \u251c\u2500\u2500 LICENSE \u251c\u2500\u2500 mbari_wec_template_py \u2502 \u251c\u2500\u2500 controller.py \u2502 \u2514\u2500\u2500 __init__.py \u251c\u2500\u2500 package.xml \u251c\u2500\u2500 README.md \u251c\u2500\u2500 resource \u2502 \u2514\u2500\u2500 mbari_wec_template_py \u251c\u2500\u2500 setup.cfg \u251c\u2500\u2500 setup.py \u2514\u2500\u2500 test \u251c\u2500\u2500 test_copyright.py \u251c\u2500\u2500 test_flake8.py \u2514\u2500\u2500 test_pep257.py","title":"Creating your own repo from the template"},{"location":"Tutorials/ROS2/PythonTemplate/#customizing-the-controller","text":"You may also refer to the README.md in your newly cloned repository.","title":"Customizing the controller"},{"location":"Tutorials/ROS2/PythonTemplate/#modify-template-for-your-package","text":"Replace mbari_wec_template_py with your package name and modify other fields as necessary in: package.xml (lines 4-8) package.xml 1 2 3 4 5 6 7 8 <?xml version=\"1.0\"?> <?xml-model href=\"http://download.ros.org/schema/package_format3.xsd\" schematypens=\"http://www.w3.org/2001/XMLSchema\"?> <package format= \"3\" > <name> repo_name </name> <!-- Update package name --> <version> 3.14 </version> <!-- Update version --> <description> Your Controller Description </description> <!-- Update description --> <maintainer email= \"your@email\" > Your Name </maintainer> <!-- Update email and name --> <license> Your License </license> <!-- Update license --> setup.py (lines 7, 11, 22-25, 29) setup.py 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 package_name = 'your_package_name' # Update package name setup ( name = package_name , version = '3.14' , # Update version packages = [ f ' { package_name } ' ], data_files = [ ( 'share/ament_index/resource_index/packages' , [ 'resource/' + package_name ]), ( 'share/' + package_name , [ 'package.xml' ]), ( os . path . join ( 'share' , package_name , 'launch' ), glob ( 'launch/*.launch.py' )), ( os . path . join ( 'share' , package_name , 'config' ), glob ( 'config/*.yaml' )) ], install_requires = [ 'setuptools' ], zip_safe = True , maintainer = 'Your Name' , # Update name maintainer_email = 'your@email' , # Update email description = 'Your package description' , # Update package description license = 'Your License' , # Update license tests_require = [ 'pytest' ], entry_points = { 'console_scripts' : [ f 'your_controller_name = { package_name } .controller:main' , # Update controller executable name setup.cfg (lines 2, 4) Update script_dir and install_scripts locations with your package name setup.cfg 1 2 3 4 [develop] script_dir = $base/lib/your_package_name [install] install_scripts = $base/lib/your_package_name launch/controller.launch.py (lines 22, 35-36) launch/controller.launch.py 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 package_name = 'your_package_name' # Update package name def generate_launch_description (): ld = LaunchDescription () config = os . path . join ( get_package_share_directory ( package_name ), 'config' , 'controller.yaml' ) node = Node ( package = package_name , name = 'your_controller_name' , # Update controller name (same as name in config.yaml) executable = 'your_controller_name' , # Update controller executable name from setup.py config/controller.yaml (line 1) Update first line with your controller name (same as node name in launch file) config/controller.yaml 1 2 3 /your_controller_name : ros__parameters : foo : 1.0 and rename two files/folders the empty file resource/mbari_wec_template_py the Python package mbari_wec_template_py containing controller.py resulting in the following folder structure: repo_name \u251c\u2500\u2500 config \u2502 \u2514\u2500\u2500 controller.yaml \u251c\u2500\u2500 launch \u2502 \u2514\u2500\u2500 controller.launch.py \u251c\u2500\u2500 LICENSE \u251c\u2500\u2500 your_package_name \u2502 \u251c\u2500\u2500 controller.py \u2502 \u2514\u2500\u2500 __init__.py \u251c\u2500\u2500 package.xml \u251c\u2500\u2500 README.md \u251c\u2500\u2500 resource \u2502 \u2514\u2500\u2500 your_package_name \u251c\u2500\u2500 setup.cfg \u251c\u2500\u2500 setup.py \u2514\u2500\u2500 test \u251c\u2500\u2500 test_copyright.py \u251c\u2500\u2500 test_flake8.py \u2514\u2500\u2500 test_pep257.py Modify setup.py as desired and add any dependencies in package.xml following standard ROS 2 documentation.","title":"Modify template for your package"},{"location":"Tutorials/ROS2/PythonTemplate/#implement-controller","text":"Assuming you have followed the above and renamed the Python package mbari_wec_template_py to your package name, <your_package_name>/controller.py is stubbed out to implement your custom external controller. You may also use config/controller.yaml for any policy parameters.","title":"Implement Controller"},{"location":"Tutorials/ROS2/PythonTemplate/#controlpolicy","text":"You may use the class ControlPolicy in <your_package_name>/controller.py to implement your controller. 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 class ControlPolicy ( object ): def __init__ ( self ): # Define any parameter variables here self . foo = 1.0 self . update_params () def update_params ( self ): \"\"\"Update dependent variables after reading in params.\"\"\" self . bar = 10.0 * self . foo pass # remove if there's anything to set above # Modify function inputs as desired def target ( self , * args , ** kwargs ): \"\"\"Calculate target value from feedback inputs.\"\"\" # secret sauce return 0.0 # obviously, modify to return proper target value Set any configurable parameters in __init__ on line 23 23 24 25 26 27 def __init__ ( self ): # Define any parameter variables here self . foo = 1.0 self . update_params () Set any dependent variables in update_params on line 29 29 30 31 32 33 def update_params ( self ): \"\"\"Update dependent variables after reading in params.\"\"\" self . bar = 10.0 * self . foo pass # remove if there's anything to set above Declare/get/update params in the set_params function of the Controller class on line 113 113 114 115 116 117 118 119 120 def set_params ( self ): \"\"\"Use ROS2 declare_parameter and get_parameter to set policy params.\"\"\" self . declare_parameter ( 'foo' , self . policy . foo ) self . policy . foo = \\ self . get_parameter ( 'foo' ) . get_parameter_value () . double_value # recompute any dependent variables self . policy . update_params () Then, your control logic will go in the target function on line 36. Modify the input args as well as the return value as necessary 35 36 37 38 39 40 41 # Modify function inputs as desired def target ( self , * args , ** kwargs ): # noqa: D202 \"\"\"Calculate target value from feedback inputs.\"\"\" # secret sauce return 0.0 # obviously, modify to return proper target value","title":"ControlPolicy"},{"location":"Tutorials/ROS2/PythonTemplate/#controller","text":"The Controller class contains an instance of ControlPolicy as the member variable, self.policy . The self.policy.target function may be called anywhere within the Controller class. You may call it inside any of the data callbacks to enable feedback control (for example): # To subscribe to any topic, simply define the specific callback, e.g. power_callback def power_callback ( self , data ): '''Callback for '/power_data' topic from Power Controller''' # get target value from control policy target_value = self . policy . target ( data . rpm , data . scale , data . retract ) # send a command, e.g. winding current self . send_pc_wind_curr_command ( target_value , blocking = False ) Or, set up a loop in main() and run open-loop: 123 124 125 126 127 128 129 130 131 132 133 def main (): rclpy . init () controller = Controller () rate = controller . create_rate ( 50.0 ) # Hz while rclpy . ok (): # Open-loop control logic rclpy . spin_once ( controller ) rate . sleep () rclpy . shutdown () You may get feedback data from any of the buoy topics by simply creating a specific callback listed below. For feedback data you'd like to use in another area of the class, feel free to assign them to class variables. (Delete any callbacks you don't need in the Controller class) Available callback functions: /ahrs_data \u2192 def ahrs_callback(self, data): /battery_data \u2192 def battery_callback(self, data): /spring_data \u2192 def spring_callback(self, data): /power_data \u2192 def power_callback(self, data): /trefoil_data \u2192 def trefoil_callback(self, data): /powerbuoy_data \u2192 def powerbuoy_callback(self, data): You may also send commands from within the Controller class: self.send_pump_command(duration_mins, blocking=False) self.send_valve_command(duration_sec, blocking=False) self.send_pc_wind_curr_command(wind_curr_amps, blocking=False) self.send_pc_bias_curr_command(bias_curr_amps, blocking=False) self.send_pc_scale_command(scale_factor, blocking=False) self.send_pc_retract_command(retract_factor, blocking=False) In the Controller constructor, you may also uncomment lines 55 or 56 to set the publish rates for the Spring or Power Controllers on the buoy. These controllers default to publishing at 10Hz. You can call commands to set the rates anywhere from 10Hz to 50Hz (default argument is 50Hz). 46 47 48 49 50 51 52 53 54 55 56 def __init__ ( self ): super () . __init__ ( 'controller' ) self . policy = ControlPolicy () self . set_params () # set packet rates from controllers here # controller defaults to publishing @ 10Hz # call these to set rate to 50Hz or provide argument for specific rate # self.set_pc_pack_rate_param() # set PC publish rate to 50Hz # self.set_sc_pack_rate_param() # set SC publish rate to 50Hz","title":"Controller"},{"location":"Tutorials/ROS2/PythonTemplate/#build-test-run","text":"At this point, your new package should build, pass tests, and run against the sim (will connect but do nothing). It is assumed that you have already installed or built the buoy packages. From your workspace (e.g. ~/controller_ws ) build your package: $ colcon build Starting >>> mbari_wec_template_py --- stderr: mbari_wec_template_py /usr/lib/python3/dist-packages/setuptools/command/install.py:34: SetuptoolsDeprecationWarning: setup.py install is deprecated. Use build and pip and other standards-based tools. warnings.warn( --- Finished <<< mbari_wec_template_py [0.74s] Summary: 1 package finished [0.89s] 1 package had stderr output: mbari_wec_template_py You may also build only your new controller package (if you have other packages in the workspace) using: $ colcon build --packages-up-to <your_package_name> Then, source and test: $ source install/local_setup.bash $ colcon test Starting >>> mbari_wec_template_py --- stderr: mbari_wec_template_py =============================== warnings summary =============================== test/test_flake8.py::test_flake8 test/test_flake8.py::test_flake8 Warning: SelectableGroups dict interface is deprecated. Use select. -- Docs: https://docs.pytest.org/en/stable/warnings.html --- Finished <<< mbari_wec_template_py [0.74s] Summary: 1 package finished [0.87s] 1 package had stderr output: mbari_wec_template_py Or, you may test only your new controller package using: $ colcon test --packages-select <your_package_name> Next, in another terminal run the sim (after sourcing the sim packages of course): $ ros2 launch buoy_gazebo mbari_wec.launch.py Now, in the previous terminal, launch the empty controller: $ ros2 launch <your_package_name> controller.launch.py And you should see something similar to: [INFO] [launch]: Default logging verbosity is set to INFO [INFO] [controller-1]: process started with pid [1409887] [controller-1] [INFO] [1678130539.867493131] [controller]: Subscribing to <class 'buoy_interfaces.msg._xb_record.XBRecord'> on '/ahrs_data' [controller-1] [INFO] [1678130540.031500810] [controller]: Subscribing to <class 'buoy_interfaces.msg._bc_record.BCRecord'> on '/battery_data' [controller-1] [INFO] [1678130540.031972332] [controller]: Subscribing to <class 'buoy_interfaces.msg._sc_record.SCRecord'> on '/spring_data' [controller-1] [INFO] [1678130540.032390456] [controller]: Subscribing to <class 'buoy_interfaces.msg._pc_record.PCRecord'> on '/power_data' [controller-1] [INFO] [1678130540.032810815] [controller]: Subscribing to <class 'buoy_interfaces.msg._tf_record.TFRecord'> on '/trefoil_data' [controller-1] [INFO] [1678130540.033268687] [controller]: Subscribing to <class 'buoy_interfaces.msg._xb_record.XBRecord'> on '/xb_record' [controller-1] [INFO] [1678130540.033703510] [controller]: Subscribing to <class 'buoy_interfaces.msg._bc_record.BCRecord'> on '/bc_record' [controller-1] [INFO] [1678130540.034091374] [controller]: Subscribing to <class 'buoy_interfaces.msg._sc_record.SCRecord'> on '/sc_record' [controller-1] [INFO] [1678130540.034467140] [controller]: Subscribing to <class 'buoy_interfaces.msg._pc_record.PCRecord'> on '/pc_record' [controller-1] [INFO] [1678130540.034868686] [controller]: Subscribing to <class 'buoy_interfaces.msg._tf_record.TFRecord'> on '/tf_record' [controller-1] [INFO] [1678130540.035298496] [controller]: Subscribing to <class 'buoy_interfaces.msg._pb_record.PBRecord'> on '/powerbuoy_data' [controller-1] [INFO] [1678130540.286577653] [controller]: /pc_pack_rate_command not available [controller-1] [INFO] [1678130540.537643441] [controller]: /sc_pack_rate_command not available [controller-1] [INFO] [1678130540.538230613] [controller]: Found all required services.","title":"Build, Test, Run"},{"location":"Tutorials/ROS2/PythonTemplate/#example","text":"An example using this interface will follow in the next tutorial: Linear Damper Example (Python)","title":"Example"},{"location":"Tutorials/Simulation/RunSimulator/","text":"Introduction This tutorial will illustrate how to start the buoy simulation in Gazebo, when the simulation is running, a rendering of the buoy system motions will be visible, and ROS2 messages will be published that represent the buoy systems state. The simulation also provides the same ROS2 services the real buoy does, so will respond to ROS2 messages appropriately. Subsequent tutorials will illustrate how to view and plot data being published by the simulation, view data logs being generated, and control the simulated buoy with the command-line tool that is available on the buoy. Run To run the simulator, it is necessary to source the workspace in a separate terminal than was used to build the application. Therefore, open a new terminal window and do the following: Source the workspace $ . ~/buoy_ws/install/setup.sh Launch the simulation $ ros2 launch buoy_gazebo mbari_wec.launch.py The Gazebo rendering of the buoy system should become visible and appear as follows: To start the simulation, press the \"play\" arrow in the lower left, the buoy should start to move in response to incoming waves. It is also possible to adjust various parameters such as the sea-state, visibility of the rendering, and speed the simulation will run relative to real-time. These topics are covered in a later tutorial. To view the ROS2 messages and associated data while the simulation runs, proceed to the next tutorial: View ROS2 Messages","title":"RunSimulator"},{"location":"Tutorials/Simulation/RunSimulator/#introduction","text":"This tutorial will illustrate how to start the buoy simulation in Gazebo, when the simulation is running, a rendering of the buoy system motions will be visible, and ROS2 messages will be published that represent the buoy systems state. The simulation also provides the same ROS2 services the real buoy does, so will respond to ROS2 messages appropriately. Subsequent tutorials will illustrate how to view and plot data being published by the simulation, view data logs being generated, and control the simulated buoy with the command-line tool that is available on the buoy.","title":"Introduction"},{"location":"Tutorials/Simulation/RunSimulator/#run","text":"To run the simulator, it is necessary to source the workspace in a separate terminal than was used to build the application. Therefore, open a new terminal window and do the following: Source the workspace $ . ~/buoy_ws/install/setup.sh Launch the simulation $ ros2 launch buoy_gazebo mbari_wec.launch.py The Gazebo rendering of the buoy system should become visible and appear as follows: To start the simulation, press the \"play\" arrow in the lower left, the buoy should start to move in response to incoming waves. It is also possible to adjust various parameters such as the sea-state, visibility of the rendering, and speed the simulation will run relative to real-time. These topics are covered in a later tutorial. To view the ROS2 messages and associated data while the simulation runs, proceed to the next tutorial: View ROS2 Messages","title":"Run"},{"location":"Tutorials/Simulation/SimulatorInteraction/","text":"Run Source the workspace . ~/buoy_ws/install/setup.sh Launch the simulation ros2 launch buoy_gazebo mbari_wec.launch.py rviz:=True","title":"SimulatorInteraction"},{"location":"Tutorials/Simulation/SimulatorInteraction/#run","text":"Source the workspace . ~/buoy_ws/install/setup.sh Launch the simulation ros2 launch buoy_gazebo mbari_wec.launch.py rviz:=True","title":"Run"},{"location":"Tutorials/Simulation/SimulatorOutputLogs/","text":"Run Source the workspace . ~/buoy_ws/install/setup.sh Launch the simulation ros2 launch buoy_gazebo mbari_wec.launch.py rviz:=True","title":"SimulatorOutputLogs"},{"location":"Tutorials/Simulation/SimulatorOutputLogs/#run","text":"Source the workspace . ~/buoy_ws/install/setup.sh Launch the simulation ros2 launch buoy_gazebo mbari_wec.launch.py rviz:=True","title":"Run"},{"location":"Tutorials/Simulation/SimulatorOutputPbcmd/","text":"Run Source the workspace . ~/buoy_ws/install/setup.sh Launch the simulation ros2 launch buoy_gazebo mbari_wec.launch.py rviz:=True","title":"SimulatorOutputPbcmd"},{"location":"Tutorials/Simulation/SimulatorOutputPbcmd/#run","text":"Source the workspace . ~/buoy_ws/install/setup.sh Launch the simulation ros2 launch buoy_gazebo mbari_wec.launch.py rviz:=True","title":"Run"},{"location":"Tutorials/Simulation/SimulatorOutputPlotjuggler/","text":"\" PlotJuggler \" is a plotting program that includes support for ROS2 messages, and allows real-time plotting of data from ROS2 messages while the simulator runs, as well as plotting of logged data. To install, see instructions here . If using the supplied docker images, this step is not necessary as the software is already installed. To start, issue the following command in a window where the environment has already been sourced using $ . ~/buoy_ws/install/setup.sh : $ ros2 run plotjuggler plotjuggler After an entertaining splash-screen, a blank PlotJuggler screen will appear. Under \"Streaming\" (upper left, second item below \"File\"), select the \"ROS2 Topic Subscriber\" option and click \"Start\". A new window will appear showing the ROS2 topics available on the system. Note that the Gazebo Simulator of the buoy must be running for the ROS2 topics that contain the buoy data to be present. Select the /arhs_data, /power_data, /spring_data, battery_data, heavecone_data and /xb_data topics and click \"OK\" The selected topics will appear in the \"Timeseries List\" window, and selecting the carot to the left of each topic will expand them and show the data that can be plotted. Note that these topics and data are the same as are visible using the $ ros2 topic list and $ ros2 topic echo ... commands from the command-line. Dragging any data item into the plot field on the right will plot that data on a scrolling graph. The time-extent of the graph can be changed using the \"Buffer\" text-box under the \"Streaming\" box in the upper left. Graphs can be split horizontally and vertically to make room for more data items, see this guide for information on manipulating the PlotJuggler windows. After a bit of data selection, the window can look like the example below and show many data items in real-time. Under the \"File\" box in the upper left, there are options to save and retrieve this layout to avoid setting up the windows at each invocation of PlotJuggler. PlotJuggler will continue to run through re-starts of the simulator, so it is often not necessary to re-start PlotJuggler often.","title":"SimulatorOutputPlotjuggler"},{"location":"Tutorials/Simulation/SimulatorOutputROS/","text":"ROS2 Message While running, the simulator generates exactly the same ROS2 messages that the buoy hardware does during operation. These are grouped into ROS2 topics that corresponds to data being produced by each micro-controller or instrument on the buoy. To see all ROS2 topics being published to on the system, issue the following command (after sourcing the workspace if needed in a new terminal $ . ~/buoy_ws/install/setup.sh $ ros2 topic list /ahrs_data /clock /joint_states /parameter_events /power_data /rosout /spring_data /tf /tf_static /xb_imu The topics /ahrs_data, /battery_data, /spring_data, /power_data, and /heavecone_data coorespond to the buoy-based instrumentation (AHRS), battery controller, spring controller, power-converter controller, and heave-cone controller. To see the data being published in these topics, issue the following command and the data will scroll by: $ ros2 topic echo power_data --- header: stamp: sec: 712 nanosec: 710000000 frame_id: '' seq_num: 6703 rpm: 369.927978515625 sd_rpm: 0.0 voltage: 313.98431396484375 draw_curr_limit: 0.0 bcurrent: -0.14509780704975128 wcurrent: -0.2554447054862976 torque: 0.0 diff_press: 2.9100000858306885 bias_current: 0.0 loaddc: 0.0 scale: 1.0 retract: 0.6000000238418579 target_v: 0.0 target_a: -0.2554447054862976 charge_curr_limit: 0.0 status: 0 --- The data in each topic corresponds to the message descriptions which can be seen here along wit a description of each field. Several of these topics are only available in simulation, and only /ahrs_data, /battery_data, /spring_data, /power_data, and /heavecone_data will be present on the real buoy. The next tutorial \" View Messages with Plotjuggler \" shows how to conveniently plot these data items while the simulator is running.","title":"SimulatorOutputROS"},{"location":"Tutorials/Simulation/SimulatorOutputROS/#ros2-message","text":"While running, the simulator generates exactly the same ROS2 messages that the buoy hardware does during operation. These are grouped into ROS2 topics that corresponds to data being produced by each micro-controller or instrument on the buoy. To see all ROS2 topics being published to on the system, issue the following command (after sourcing the workspace if needed in a new terminal $ . ~/buoy_ws/install/setup.sh $ ros2 topic list /ahrs_data /clock /joint_states /parameter_events /power_data /rosout /spring_data /tf /tf_static /xb_imu The topics /ahrs_data, /battery_data, /spring_data, /power_data, and /heavecone_data coorespond to the buoy-based instrumentation (AHRS), battery controller, spring controller, power-converter controller, and heave-cone controller. To see the data being published in these topics, issue the following command and the data will scroll by: $ ros2 topic echo power_data --- header: stamp: sec: 712 nanosec: 710000000 frame_id: '' seq_num: 6703 rpm: 369.927978515625 sd_rpm: 0.0 voltage: 313.98431396484375 draw_curr_limit: 0.0 bcurrent: -0.14509780704975128 wcurrent: -0.2554447054862976 torque: 0.0 diff_press: 2.9100000858306885 bias_current: 0.0 loaddc: 0.0 scale: 1.0 retract: 0.6000000238418579 target_v: 0.0 target_a: -0.2554447054862976 charge_curr_limit: 0.0 status: 0 --- The data in each topic corresponds to the message descriptions which can be seen here along wit a description of each field. Several of these topics are only available in simulation, and only /ahrs_data, /battery_data, /spring_data, /power_data, and /heavecone_data will be present on the real buoy. The next tutorial \" View Messages with Plotjuggler \" shows how to conveniently plot these data items while the simulator is running.","title":"ROS2 Message"},{"location":"Tutorials/Simulation/SimulatorParameters/","text":"Start-up parameters There are a number of parameters that change the behavior of the simulator, and must be specified at start-up: Sea-State: This is specified as a Wave Height and Period. If a positive value of wave-period is specified, a Pierson-Moskowitch spectrum with the specfied significant wave-height and peak-period is used. If a negative value of wave-period is specified, a mono-chromatic incoming wave at the specified period and height is used. Real-time factor: This specifies how fast the simulator will run. A real-time factor of 1.0 cooresponds to the simulation time proceeding at the same speed as the wall-clock. A larger value runs the simulator faster than real-time, practical upper limits on normal hardware are a real-time factor of about 30, and if this is not possible the simulator will run as fast as possible. Heave-cone door position: The simulation can be run with the heave-cone doors either open, or closed. This can not be changed while the simulation is running. Simulation Rendering: The simulator can be run with our without a visual rendering of the system. The simulator may run faster without the rendering graphics. Run-time control","title":"SimulatorParameters"},{"location":"Tutorials/Simulation/SimulatorParameters/#start-up-parameters","text":"There are a number of parameters that change the behavior of the simulator, and must be specified at start-up: Sea-State: This is specified as a Wave Height and Period. If a positive value of wave-period is specified, a Pierson-Moskowitch spectrum with the specfied significant wave-height and peak-period is used. If a negative value of wave-period is specified, a mono-chromatic incoming wave at the specified period and height is used. Real-time factor: This specifies how fast the simulator will run. A real-time factor of 1.0 cooresponds to the simulation time proceeding at the same speed as the wall-clock. A larger value runs the simulator faster than real-time, practical upper limits on normal hardware are a real-time factor of about 30, and if this is not possible the simulator will run as fast as possible. Heave-cone door position: The simulation can be run with the heave-cone doors either open, or closed. This can not be changed while the simulation is running. Simulation Rendering: The simulator can be run with our without a visual rendering of the system. The simulator may run faster without the rendering graphics.","title":"Start-up parameters"},{"location":"Tutorials/Simulation/SimulatorParameters/#run-time-control","text":"","title":"Run-time control"}]}